import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type'
};
// =====================================================
// FUNCIONES SEO CON GOOGLE PLACES INTEGRATION (EXISTENTES)
// =====================================================
const googlePlacesCache = new Map();
async function getLocationGooglePlacesData(supabaseClient, locationName) {
  if (!locationName) return null;
  if (googlePlacesCache.has(locationName)) {
    console.log(`üéØ Cache hit para Google Places: ${locationName}`);
    return googlePlacesCache.get(locationName);
  }
  console.log(`üîç Obteniendo datos de Google Places para: ${locationName}`);
  try {
    const { data: locationInsight, error: locationError } = await supabaseClient.from('location_insights_with_places').select('id, location_name, services_score').ilike('location_name', `%${locationName}%`).eq('status', 'active').single();
    if (locationError || !locationInsight) {
      console.log(`‚ö†Ô∏è No se encontr√≥ location_insight para: ${locationName}`);
      return null;
    }
    const { data: placesData, error: placesError } = await supabaseClient.from('google_places_data').select(`
        place_name, place_category, place_type, rating, 
        user_ratings_total, distance_display, business_status,
        is_featured, relevance_score, address
      `).eq('location_insight_id', locationInsight.id).eq('status', 'active').order('distance_meters', {
      ascending: true
    });
    if (placesError) {
      console.error(`‚ùå Error obteniendo Google Places data:`, placesError);
      return null;
    }
    const placesByCategory = {};
    const featuredPlaces = [];
    (placesData || []).forEach((place)=>{
      if (!placesByCategory[place.place_category]) {
        placesByCategory[place.place_category] = [];
      }
      placesByCategory[place.place_category].push(place);
      if (place.is_featured && featuredPlaces.length < 10) {
        featuredPlaces.push(place);
      }
    });
    const stats = {
      total_places: placesData?.length || 0,
      categories_count: Object.keys(placesByCategory).length,
      featured_count: featuredPlaces.length,
      avg_rating: placesData?.length > 0 ? (placesData.filter((p)=>p.rating).reduce((sum, p)=>sum + p.rating, 0) / placesData.filter((p)=>p.rating).length).toFixed(1) : null,
      services_score: locationInsight.services_score || 0
    };
    const result = {
      location_insight_id: locationInsight.id,
      location_name: locationInsight.location_name,
      places_by_category: placesByCategory,
      featured_places: featuredPlaces,
      stats
    };
    googlePlacesCache.set(locationName, result);
    setTimeout(()=>googlePlacesCache.delete(locationName), 30 * 60 * 1000);
    return result;
  } catch (error) {
    console.error(`‚ùå Error cr√≠tico obteniendo Google Places data:`, error);
    return null;
  }
}
function optimizePropertyImages(property) {
  const location = property.sectors?.name || property.cities?.name || '';
  const propertyType = property.property_categories?.name || 'Propiedad';
  const allImages = new Map();
  if (property.main_image_url && property.main_image_url.trim()) {
    allImages.set(property.main_image_url, {
      url: property.main_image_url,
      title: `${property.name} - Imagen Principal`,
      description: `${propertyType} de ${property.bedrooms} habitaciones en ${location}`,
      is_main: true,
      sort_order: 0,
      source: 'main'
    });
  }
  if (property.property_images && property.property_images.length > 0) {
    property.property_images.forEach((img, index)=>{
      if (img.url && img.url.trim()) {
        const key = img.url;
        if (!allImages.has(key)) {
          allImages.set(key, {
            url: img.url,
            title: img.title || `${property.name} - Vista ${index + 1}`,
            description: img.description || `${propertyType} en ${location}`,
            is_main: img.is_main || false,
            sort_order: img.sort_order || index + 1,
            source: 'property_images'
          });
        }
      }
    });
  }
  if (property.gallery_images_url && typeof property.gallery_images_url === 'string') {
    const galleryUrls = property.gallery_images_url.split(',').map((url)=>url.trim()).filter((url)=>url.length > 0 && url !== ',');
    galleryUrls.forEach((url, index)=>{
      if (!allImages.has(url)) {
        allImages.set(url, {
          url: url,
          title: `${property.name} - Galer√≠a ${index + 1}`,
          description: `${propertyType} en ${location}`,
          is_main: false,
          sort_order: 100 + index,
          source: 'gallery'
        });
      }
    });
  }
  const unifiedImages = Array.from(allImages.values()).sort((a, b)=>{
    if (a.is_main && !b.is_main) return -1;
    if (!a.is_main && b.is_main) return 1;
    return a.sort_order - b.sort_order;
  }).map((img, index)=>({
      ...img,
      optimized_url: `${img.url}?w=800&h=600&q=85&f=webp`,
      thumbnail_url: `${img.url}?w=300&h=200&q=80&f=webp`,
      position: index
    }));
  const mainImage = unifiedImages.find((img)=>img.is_main) || unifiedImages[0];
  return {
    ...property,
    main_image_optimized: mainImage ? {
      url: mainImage.url,
      alt: mainImage.title,
      width: 800,
      height: 600,
      optimized_url: mainImage.optimized_url
    } : null,
    images_unified: unifiedImages,
    images_count: unifiedImages.length
  };
}
function unifyPropertyPricing(property) {
  const prices = {
    sale: null,
    rental: null,
    temp_rental: null,
    furnished_rental: null,
    display_price: null,
    price_range: null
  };
  if (property.sale_price && property.sale_price > 0) {
    prices.sale = {
      amount: property.sale_price,
      currency: property.sale_currency || 'USD',
      formatted: `$${property.sale_price.toLocaleString()} ${property.sale_currency || 'USD'}`
    };
  }
  if (property.rental_price && property.rental_price > 0) {
    prices.rental = {
      amount: property.rental_price,
      currency: property.rental_currency || 'USD',
      formatted: `$${property.rental_price.toLocaleString()} ${property.rental_currency || 'USD'}/mes`
    };
  }
  if (property.temp_rental_price && property.temp_rental_price > 0) {
    prices.temp_rental = {
      amount: property.temp_rental_price,
      currency: property.temp_rental_currency || 'USD',
      formatted: `$${property.temp_rental_price.toLocaleString()} ${property.temp_rental_currency || 'USD'}/noche`
    };
  }
  if (property.furnished_rental_price && property.furnished_rental_price > 0) {
    prices.furnished_rental = {
      amount: property.furnished_rental_price,
      currency: property.furnished_rental_currency || 'USD',
      formatted: `$${property.furnished_rental_price.toLocaleString()} ${property.furnished_rental_currency || 'USD'}/mes amueblado`
    };
  }
  if (prices.sale) {
    prices.display_price = prices.sale;
    prices.operation_type = 'sale';
  } else if (prices.rental) {
    prices.display_price = prices.rental;
    prices.operation_type = 'rental';
  } else if (prices.furnished_rental) {
    prices.display_price = prices.furnished_rental;
    prices.operation_type = 'furnished_rental';
  } else if (prices.temp_rental) {
    prices.display_price = prices.temp_rental;
    prices.operation_type = 'temp_rental';
  }
  return {
    ...property,
    pricing_unified: prices
  };
}
function generateSEOMetadata(context) {
  const { type, searchResults, property, tags, urlSegments, googlePlacesData } = context;
  let seoData = {
    title: '',
    description: '',
    keywords: [],
    h1: '',
    structured_data: {},
    og: {},
    twitter: {},
    technical: {},
    places_enrichment: null
  };
  if (type === 'single-property' || type === 'single-property-project') {
    const prop = property;
    const location = prop.sectors?.name || prop.cities?.name || 'Rep√∫blica Dominicana';
    const propertyType = prop.property_categories?.name || 'Propiedad';
    const pricing = prop.pricing_unified?.display_price;
    const price = pricing ? pricing.formatted : 'Precio disponible';
    let nearbyServices = '';
    if (googlePlacesData && googlePlacesData.featured_places?.length > 0) {
      const topServices = googlePlacesData.featured_places.slice(0, 3);
      nearbyServices = ` Cerca de ${topServices.map((s)=>s.place_name).join(', ')}.`;
    }
    seoData.title = `${prop.name} | ${propertyType} en ${location} | CLIC Inmobiliaria`;
    seoData.description = `${propertyType} de ${prop.bedrooms} habitaciones y ${prop.bathrooms} ba√±os en ${location}. ${price}. ${prop.built_area}m¬≤.${nearbyServices} Ver fotos y detalles.`;
    seoData.h1 = prop.name;
    seoData.keywords = [
      `${propertyType.toLowerCase()} ${location.toLowerCase()}`,
      `${prop.bedrooms} habitaciones ${location.toLowerCase()}`,
      `comprar ${propertyType.toLowerCase()} ${location.toLowerCase()}`,
      'bienes raices republica dominicana'
    ];
    if (googlePlacesData) {
      const serviceKeywords = Object.keys(googlePlacesData.places_by_category).map((category)=>`cerca de ${category.replace('_', ' ')}`).slice(0, 3);
      seoData.keywords.push(...serviceKeywords);
    }
    seoData.structured_data = {
      "@context": "https://schema.org",
      "@type": "RealEstateListing",
      "name": prop.name,
      "description": seoData.description,
      "url": `https://clic.do/${prop.slug_url}`,
      "image": [
        prop.main_image_optimized?.url
      ].filter(Boolean),
      "offers": {
        "@type": "Offer",
        "price": pricing?.amount,
        "priceCurrency": pricing?.currency,
        "availability": prop.property_status === 'Publicada' ? "InStock" : "OutOfStock"
      },
      "address": {
        "@type": "PostalAddress",
        "addressLocality": location,
        "addressCountry": "DO"
      },
      "floorSize": {
        "@type": "QuantitativeValue",
        "value": prop.built_area,
        "unitCode": "MTK"
      },
      "numberOfRooms": prop.bedrooms,
      "numberOfBathroomsTotal": prop.bathrooms
    };
    if (googlePlacesData && googlePlacesData.featured_places?.length > 0) {
      seoData.structured_data.nearbyPoints = googlePlacesData.featured_places.slice(0, 5).map((place)=>({
          "@type": "Place",
          "name": place.place_name,
          "description": place.place_category,
          "address": place.address
        }));
    }
  } else if (type === 'property-list') {
    const properties = searchResults?.properties || [];
    const count = searchResults?.pagination?.totalCount || properties.length;
    const location = extractLocationFromTags(tags) || 'Rep√∫blica Dominicana';
    const propertyType = extractPropertyTypeFromTags(tags) || 'Propiedades';
    const operation = extractOperationFromTags(tags) || 'Venta';
    const displayPrices = properties.map((p)=>p.pricing_unified?.display_price?.amount).filter((p)=>p && p > 0).sort((a, b)=>a - b);
    const minPrice = displayPrices.length > 0 ? displayPrices[0] : null;
    const maxPrice = displayPrices.length > 0 ? displayPrices[displayPrices.length - 1] : null;
    let servicesInfo = '';
    if (googlePlacesData && googlePlacesData.stats.total_places > 0) {
      const topCategories = Object.keys(googlePlacesData.places_by_category).sort((a, b)=>googlePlacesData.places_by_category[b].length - googlePlacesData.places_by_category[a].length).slice(0, 3);
      const categoryNames = {
        'banks': 'bancos',
        'hospitals': 'centros m√©dicos',
        'schools': 'colegios',
        'supermarkets': 'supermercados',
        'shopping_malls': 'centros comerciales',
        'restaurants': 'restaurantes'
      };
      const services = topCategories.map((cat)=>categoryNames[cat] || cat).join(', ');
      servicesInfo = ` Zona con excelentes servicios: ${services}.`;
    }
    seoData.title = `${propertyType} en ${operation} en ${location} | ${count} Disponibles | CLIC Inmobiliaria`;
    let priceInfo = '';
    if (minPrice && maxPrice) {
      if (minPrice === maxPrice) {
        priceInfo = `Precio: $${minPrice.toLocaleString()}`;
      } else {
        priceInfo = `Precios desde $${minPrice.toLocaleString()} hasta $${maxPrice.toLocaleString()}`;
      }
    }
    seoData.description = `Descubre ${count} ${propertyType.toLowerCase()} en ${operation.toLowerCase()} en ${location}. ${priceInfo}.${servicesInfo} ‚úÖ Tours virtuales ‚úÖ Financiamiento disponible`;
    seoData.h1 = `${propertyType} en ${operation} en ${location} - ${count} Propiedades Disponibles`;
    seoData.keywords = [
      `${propertyType.toLowerCase()} ${location.toLowerCase()}`,
      `${operation.toLowerCase()} ${propertyType.toLowerCase()} ${location.toLowerCase()}`,
      `bienes raices ${location.toLowerCase()}`,
      'inmobiliaria republica dominicana',
      'propiedades republica dominicana'
    ];
    seoData.structured_data = {
      "@context": "https://schema.org",
      "@type": "SearchResultsPage",
      "name": seoData.title,
      "description": seoData.description,
      "url": `https://clic.do/${urlSegments?.join('/') || ''}`,
      "mainEntity": {
        "@type": "ItemList",
        "numberOfItems": count,
        "itemListElement": properties.slice(0, 10).map((prop, index)=>({
            "@type": "RealEstateListing",
            "position": index + 1,
            "name": prop.name,
            "url": `https://clic.do/${prop.slug_url}`,
            "offers": {
              "@type": "Offer",
              "price": prop.pricing_unified?.display_price?.amount,
              "priceCurrency": prop.pricing_unified?.display_price?.currency
            }
          }))
      }
    };
    if (googlePlacesData) {
      seoData.places_enrichment = {
        total_services: googlePlacesData.stats.total_places,
        services_score: googlePlacesData.stats.services_score,
        avg_rating: googlePlacesData.stats.avg_rating,
        top_categories: Object.keys(googlePlacesData.places_by_category),
        featured_services: googlePlacesData.featured_places.slice(0, 5)
      };
    }
  }
  seoData.og = {
    title: seoData.title,
    description: seoData.description,
    image: type === 'single-property' ? property.main_image_optimized?.url : searchResults?.properties?.[0]?.main_image_optimized?.url || 'https://clic.do/default-og-image.jpg',
    url: `https://clic.do/${urlSegments?.join('/') || ''}`,
    type: "website",
    site_name: "CLIC Inmobiliaria",
    locale: "es_DO"
  };
  seoData.twitter = {
    card: "summary_large_image",
    title: seoData.title,
    description: seoData.description,
    image: seoData.og.image,
    site: "@clicinmobiliaria"
  };
  seoData.technical = {
    robots: {
      index: true,
      follow: true,
      "max-snippet": -1,
      "max-image-preview": "large",
      "max-video-preview": -1
    },
    sitemap: {
      lastModified: new Date().toISOString(),
      changeFreq: type === 'single-property' ? "weekly" : "daily",
      priority: type === 'single-property' ? 0.8 : 0.6
    }
  };
  return seoData;
}
// =====================================================
// FUNCIONES DE B√öSQUEDA OPTIMIZADAS (EXISTENTES)
// =====================================================
async function searchPropertiesByTags(supabaseClient, tagIds, page = 1, limit = 30) {
  if (tagIds.length === 0) {
    return {
      properties: [],
      totalCount: 0,
      currentPage: page,
      hasMore: false,
      itemsPerPage: limit
    };
  }
  try {
    console.log(`üîç Buscando propiedades con tags: [${tagIds.join(', ')}], p√°gina: ${page}, l√≠mite: ${limit}`);
    let totalCount = 0;
    let validPropertyIds = [];
    const { data: rpcPropertyIds, error: rpcError } = await supabaseClient.rpc('get_properties_with_all_tags', {
      tag_ids: tagIds
    });
    if (!rpcError && rpcPropertyIds && rpcPropertyIds.length > 0) {
      validPropertyIds = rpcPropertyIds;
      totalCount = rpcPropertyIds.length;
      console.log(`‚úÖ RPC exitoso: ${totalCount} propiedades encontradas`);
    } else {
      console.log('üîÑ Usando m√©todo fallback con content_tags');
      const { data: contentTags, error: contentTagsError } = await supabaseClient.from('content_tags').select('content_id, tag_id').eq('content_type', 'properties').in('tag_id', tagIds);
      if (contentTagsError || !contentTags) {
        return {
          properties: [],
          totalCount: 0,
          currentPage: page,
          hasMore: false,
          itemsPerPage: limit
        };
      }
      const tagCountByProperty = {};
      contentTags.forEach((ct)=>{
        tagCountByProperty[ct.content_id] = (tagCountByProperty[ct.content_id] || 0) + 1;
      });
      const requiredTagCount = tagIds.length;
      validPropertyIds = Object.keys(tagCountByProperty).filter((propertyId)=>tagCountByProperty[propertyId] === requiredTagCount);
      totalCount = validPropertyIds.length;
      console.log(`‚úÖ Fallback exitoso: ${totalCount} propiedades encontradas`);
    }
    if (totalCount === 0) {
      return {
        properties: [],
        totalCount: 0,
        currentPage: page,
        hasMore: false,
        itemsPerPage: limit
      };
    }
    const offset = (page - 1) * limit;
    const paginatedPropertyIds = validPropertyIds.slice(offset, offset + limit);
    console.log(`üìÑ Obteniendo p√°gina ${page}: ${paginatedPropertyIds.length} propiedades (offset: ${offset})`);
    const { data: properties, error: propertiesError } = await supabaseClient.from('properties').select(`
        id, code, name, description, agent_id, slug_url,
        sale_price, sale_currency, rental_price, rental_currency,
        temp_rental_price, temp_rental_currency, 
        furnished_rental_price, furnished_rental_currency,
        bedrooms, bathrooms, parking_spots, built_area, land_area,
        main_image_url, gallery_images_url, property_status, is_project,
        delivery_date, project_detail_id,
        property_categories(name, description),
        cities(name, provinces(name)),
        sectors(name),
        property_images(url, title, description, is_main, sort_order)
      `).in('id', paginatedPropertyIds).eq('availability', 1).eq('property_status', 'Publicada');
    if (propertiesError) {
      console.error('‚ùå Error obteniendo propiedades:', propertiesError);
      return {
        properties: [],
        totalCount: 0,
        currentPage: page,
        hasMore: false,
        itemsPerPage: limit
      };
    }
    const hasMore = offset + limit < totalCount;
    console.log(`‚úÖ B√∫squeda completada: ${properties?.length || 0} propiedades obtenidas, ${totalCount} total, hasMore: ${hasMore}`);
    return {
      properties: properties || [],
      totalCount,
      currentPage: page,
      hasMore,
      itemsPerPage: limit
    };
  } catch (error) {
    console.error('‚ùå Error en searchPropertiesByTags:', error);
    return {
      properties: [],
      totalCount: 0,
      currentPage: page,
      hasMore: false,
      itemsPerPage: limit
    };
  }
}
async function searchPropertyBySlugUrl(supabaseClient, searchPath) {
  console.log('üîç B√∫squeda por slug_url:', searchPath);
  const selectQuery = `
    id, code, name, description, agent_id, slug_url,
    sale_price, sale_currency, rental_price, rental_currency,
    temp_rental_price, temp_rental_currency, 
    furnished_rental_price, furnished_rental_currency,
    bedrooms, bathrooms, parking_spots, built_area, land_area,
    main_image_url, gallery_images_url, property_status, is_project,
    delivery_date, project_detail_id,
    property_categories(name, description),
    cities(name, provinces(name)),
    sectors(name),
    property_images(url, title, description, is_main, sort_order),
    property_amenities(amenity_id, value, amenities(name, icon, category))
  `;
  const searchVariants = [
    searchPath,
    `/${searchPath}`,
    searchPath.replace(/^\//, ''),
    `/${searchPath.replace(/^\//, '')}`
  ];
  for (const variant of searchVariants){
    const { data: property, error } = await supabaseClient.from('properties').select(selectQuery).eq('slug_url', variant).eq('availability', 1).eq('property_status', 'Publicada').single();
    if (!error && property) {
      console.log(`‚úÖ Propiedad encontrada con slug: "${variant}"`);
      return {
        found: true,
        property: property,
        searchMethod: 'exact_slug',
        matchedVariant: variant
      };
    }
  }
  return {
    found: false,
    property: null,
    searchPath: searchPath
  };
}
// =====================================================
// ‚ú® NUEVAS FUNCIONES DE PROPIEDADES SIMILARES INTEGRADAS
// =====================================================
/**
 * Obtiene los tags de una propiedad espec√≠fica
 */ async function getPropertyTags(supabaseClient, propertyId) {
  try {
    console.log('üè∑Ô∏è Obteniendo tags de la propiedad:', propertyId);
    const { data: contentTags, error } = await supabaseClient.from('content_tags').select(`
        tag_id,
        weight,
        tags!inner(id, name, slug, category, display_name)
      `).eq('content_id', propertyId).eq('content_type', 'property').order('weight', {
      ascending: false
    });
    if (error) {
      console.error('‚ùå Error obteniendo tags de propiedad:', error);
      return [];
    }
    const tags = (contentTags || []).filter((ct)=>ct.tags).map((ct)=>({
        ...ct.tags,
        weight: ct.weight || 1
      }));
    console.log('‚úÖ Tags de propiedad obtenidos:', {
      total: tags.length,
      byCategory: tags.reduce((acc, tag)=>{
        acc[tag.category] = (acc[tag.category] || 0) + 1;
        return acc;
      }, {}),
      topWeights: tags.slice(0, 5).map((t)=>`${t.category}:${t.name}(${t.weight})`)
    });
    return tags;
  } catch (error) {
    console.error('‚ùå Error en getPropertyTags:', error);
    return [];
  }
}
/**
 * Busca propiedades similares usando sistema inteligente de scoring
 */ async function getSmartSimilarProperties(supabaseClient, propertyTags, excludeId) {
  console.log('üè† === BUSCANDO PROPIEDADES SIMILARES INTELIGENTES ===');
  console.log('üìã Exclude ID:', excludeId);
  console.log('üìã Tags disponibles:', propertyTags?.length || 0);
  if (!propertyTags || propertyTags.length === 0) {
    console.log('‚ö†Ô∏è No hay tags de la propiedad, buscando propiedades aleatorias');
    return await getFallbackSimilarProperties(supabaseClient, excludeId);
  }
  try {
    const tagIds = propertyTags.map((t)=>t.id);
    console.log('üîç Buscando propiedades que tengan estos tag IDs:', tagIds);
    const { data: propertyMatches, error } = await supabaseClient.from('content_tags').select(`
        content_id,
        tag_id,
        weight,
        tags(id, name, category)
      `).eq('content_type', 'property').in('tag_id', tagIds).neq('content_id', excludeId);
    if (error || !propertyMatches) {
      console.error('‚ùå Error buscando propiedades similares:', error);
      return await getFallbackSimilarProperties(supabaseClient, excludeId);
    }
    console.log('üìä Property matches encontrados:', propertyMatches.length);
    // Sistema de scoring mejorado
    const propertyScores = {};
    const categoryWeights = {
      'operacion': 5,
      'categoria': 4,
      'ciudad': 3,
      'sector': 3,
      'provincia': 2,
      'caracteristica': 1 // Caracter√≠sticas espec√≠ficas
    };
    propertyMatches.forEach((match)=>{
      const propertyId = match.content_id;
      const tagCategory = match.tags?.category || 'caracteristica';
      const categoryWeight = categoryWeights[tagCategory] || 1;
      const tagWeight = match.weight || 1;
      if (!propertyScores[propertyId]) {
        propertyScores[propertyId] = {
          property_id: propertyId,
          total_score: 0,
          matched_tags: 0,
          categories: new Set()
        };
      }
      propertyScores[propertyId].total_score += categoryWeight * tagWeight;
      propertyScores[propertyId].matched_tags += 1;
      propertyScores[propertyId].categories.add(tagCategory);
    });
    // Filtrar propiedades que tengan al menos 2 tags coincidentes
    const validProperties = Object.values(propertyScores).filter((prop)=>prop.matched_tags >= 2).sort((a, b)=>b.total_score - a.total_score).slice(0, 6);
    if (validProperties.length === 0) {
      console.log('‚ö†Ô∏è No hay propiedades con suficientes coincidencias, bajando a 1 tag m√≠nimo');
      const validPropertiesLowBar = Object.values(propertyScores).filter((prop)=>prop.matched_tags >= 1).sort((a, b)=>b.total_score - a.total_score).slice(0, 6);
      if (validPropertiesLowBar.length === 0) {
        return await getFallbackSimilarProperties(supabaseClient, excludeId);
      }
      const propertyIds = validPropertiesLowBar.map((p)=>p.property_id);
      return await getPropertiesDetails(supabaseClient, propertyIds);
    }
    console.log('üìä Propiedades similares encontradas:', {
      totalMatches: Object.keys(propertyScores).length,
      with2PlusMatches: validProperties.length,
      topScores: validProperties.slice(0, 3).map((p)=>`${p.matched_tags} tags, score: ${p.total_score}`)
    });
    const propertyIds = validProperties.map((p)=>p.property_id);
    return await getPropertiesDetails(supabaseClient, propertyIds);
  } catch (error) {
    console.error('‚ùå Error en getSmartSimilarProperties:', error);
    return await getFallbackSimilarProperties(supabaseClient, excludeId);
  }
}
/**
 * M√©todo fallback para propiedades similares cuando no hay tags suficientes
 */ async function getFallbackSimilarProperties(supabaseClient, excludeId) {
  console.log('üîÑ Usando m√©todo fallback para propiedades similares');
  try {
    const { data: properties, error } = await supabaseClient.from('properties').select(`
        id, code, name, sale_price, rental_price, temp_rental_price,
        furnished_rental_price, sale_currency, rental_currency,
        bedrooms, bathrooms, parking_spots, built_area, land_area,
        main_image_url, gallery_images_url, is_project, slug_url,
        property_categories(name),
        cities(name, provinces(name)),
        sectors(name),
        property_images(url, title, description, is_main, sort_order)
      `).neq('id', excludeId).eq('availability', 1).eq('property_status', 'Publicada').order('created_at', {
      ascending: false
    }).limit(6);
    if (error) {
      console.error('‚ùå Error en fallback properties:', error);
      return [];
    }
    console.log('‚úÖ Propiedades fallback obtenidas:', properties?.length || 0);
    return (properties || []).map(formatSimilarProperty);
  } catch (error) {
    console.error('‚ùå Error en getFallbackSimilarProperties:', error);
    return [];
  }
}
/**
 * Obtiene detalles completos de propiedades por IDs para similares
 */ async function getPropertiesDetails(supabaseClient, propertyIds) {
  if (!propertyIds || propertyIds.length === 0) return [];
  console.log('üìã Obteniendo detalles de', propertyIds.length, 'propiedades similares');
  try {
    const { data: properties, error } = await supabaseClient.from('properties').select(`
        id, code, name, sale_price, rental_price, temp_rental_price,
        furnished_rental_price, sale_currency, rental_currency,
        bedrooms, bathrooms, parking_spots, built_area, land_area,
        main_image_url, gallery_images_url, is_project, slug_url,
        property_categories(name),
        cities(name, provinces(name)),
        sectors(name),
        property_images(url, title, description, is_main, sort_order)
      `).in('id', propertyIds).eq('availability', 1).eq('property_status', 'Publicada');
    if (error) {
      console.error('‚ùå Error obteniendo detalles de propiedades:', error);
      return [];
    }
    // Mantener el orden seg√∫n el scoring
    const orderedProperties = propertyIds.map((id)=>properties?.find((prop)=>prop.id === id)).filter(Boolean);
    console.log('‚úÖ Propiedades similares obtenidas:', orderedProperties.length);
    return orderedProperties.map(formatSimilarProperty);
  } catch (error) {
    console.error('‚ùå Error en getPropertiesDetails:', error);
    return [];
  }
}
/**
 * Formatea una propiedad para listado de similares
 */ function formatSimilarProperty(property) {
  let price = 'Precio a consultar';
  if (property.sale_price) {
    price = `$${property.sale_price.toLocaleString()} ${property.sale_currency || 'USD'}`;
  } else if (property.rental_price) {
    price = `$${property.rental_price.toLocaleString()} ${property.rental_currency || 'USD'}/mes`;
  } else if (property.temp_rental_price) {
    price = `$${property.temp_rental_price.toLocaleString()} ${property.temp_rental_currency || 'USD'}/noche`;
  } else if (property.furnished_rental_price) {
    price = `$${property.furnished_rental_price.toLocaleString()} ${property.furnished_rental_currency || 'USD'}/mes`;
  }
  // Determinar imagen principal con fallback a gallery
  let mainImage = property.main_image_url;
  if (!mainImage && property.property_images && property.property_images.length > 0) {
    const mainImg = property.property_images.find((img)=>img.is_main);
    mainImage = mainImg ? mainImg.url : property.property_images[0].url;
  }
  if (!mainImage && property.gallery_images_url) {
    if (Array.isArray(property.gallery_images_url)) {
      mainImage = property.gallery_images_url[0];
    } else if (typeof property.gallery_images_url === 'string') {
      mainImage = property.gallery_images_url.split(',')[0]?.trim();
    }
  }
  // Formatear ubicaci√≥n
  const locationParts = [
    property.sectors?.name,
    property.cities?.name
  ].filter(Boolean);
  const location = locationParts.length > 0 ? locationParts.join(', ') : 'Ubicaci√≥n no especificada';
  return {
    id: property.id,
    title: property.name,
    price: price,
    bedrooms: property.bedrooms,
    bathrooms: property.bathrooms,
    area: property.built_area || property.land_area,
    image: mainImage || '/images/placeholder-property.jpg',
    location: location,
    type: property.property_categories?.name,
    url: property.slug_url || `/propiedad/${property.id}`,
    is_project: property.is_project,
    parking_spots: property.parking_spots
  };
}
// =====================================================
// FUNCIONES DE CONTENIDO Y PROYECTO (EXISTENTES)
// =====================================================
const agentCache = new Map();
async function getPropertyAgent(supabaseClient, agentId) {
  if (!agentId) return null;
  if (agentCache.has(agentId)) {
    return agentCache.get(agentId);
  }
  try {
    const { data: agent, error } = await supabaseClient.from('users').select(`
        id, external_id, first_name, last_name, email, phone, 
        position, slug, biography, facebook_url, instagram_url, 
        twitter_url, linkedin_url, youtube_url,
        active, show_on_website, user_type, team_id
      `).eq('id', agentId).single();
    if (error) {
      console.log('‚ùå Error obteniendo agente:', error.message);
      return null;
    }
    agentCache.set(agentId, agent);
    setTimeout(()=>agentCache.delete(agentId), 15 * 60 * 1000);
    return agent;
  } catch (error) {
    console.error('‚ùå Error cr√≠tico buscando agente:', error);
    return null;
  }
}
async function getReferralAgent(supabaseClient, externalId) {
  if (!externalId) return null;
  try {
    const { data: referralAgent, error } = await supabaseClient.from('users').select(`
        id, external_id, first_name, last_name, email, phone, 
        position, slug, biography, facebook_url, instagram_url, 
        twitter_url, linkedin_url, youtube_url,
        active, show_on_website, user_type, team_id
      `).eq('external_id', externalId).eq('active', true).single();
    if (error || !referralAgent) {
      console.log('‚ö†Ô∏è Usuario referido no encontrado:', externalId);
      return null;
    }
    return referralAgent;
  } catch (error) {
    console.error('‚ùå Error buscando usuario referido:', error);
    return null;
  }
}
function formatAgent(agent, type = 'agent') {
  if (!agent) return null;
  return {
    id: agent.id,
    name: `${agent.first_name || ''} ${agent.last_name || ''}`.trim(),
    email: agent.email,
    phone: agent.phone,
    position: agent.position || 'Asesor Inmobiliario',
    slug: agent.slug,
    biography: agent.biography,
    external_id: agent.external_id,
    social: {
      facebook: agent.facebook_url,
      instagram: agent.instagram_url,
      twitter: agent.twitter_url,
      linkedin: agent.linkedin_url,
      youtube: agent.youtube_url
    },
    active: agent.active,
    show_on_website: agent.show_on_website,
    team_id: agent.team_id,
    user_type: agent.user_type,
    agent_type: type
  };
}
async function getCompleteProjectDetails(supabaseClient, projectDetailId) {
  if (!projectDetailId) return null;
  try {
    const { data: projectData, error } = await supabaseClient.from('project_details').select(`
        *,
        developers(*),
        project_typologies(*),
        project_amenities(*, amenities(*)),
        project_payment_plans(*),
        project_phases(*),
        project_availability(*, project_typologies(*)),
        project_benefits(*, project_benefits_catalog(*)),
        project_documents(*, project_documents_catalog(*))
      `).eq('id', projectDetailId).single();
    if (error) {
      console.error('‚ùå Error obteniendo detalles del proyecto:', error);
      return null;
    }
    return projectData;
  } catch (error) {
    console.error('‚ùå Error cr√≠tico en getCompleteProjectDetails:', error);
    return null;
  }
}
async function getPropertySpecificContent(supabaseClient, propertyId) {
  try {
    const { data: relations, error } = await supabaseClient.from('content_property_relations').select('content_id, content_type, relation_type, weight').eq('property_id', propertyId).order('weight', {
      ascending: false
    });
    if (error || !relations || relations.length === 0) {
      return null;
    }
    const contentByType = relations.reduce((acc, rel)=>{
      if (!acc[rel.content_type]) acc[rel.content_type] = [];
      acc[rel.content_type].push(rel.content_id);
      return acc;
    }, {});
    const [articles, videos, testimonials, faqs] = await Promise.all([
      contentByType.articles ? supabaseClient.from('articles').select('*').in('id', contentByType.articles).eq('status', 'published') : Promise.resolve({
        data: []
      }),
      contentByType.videos ? supabaseClient.from('videos').select('*').in('id', contentByType.videos).eq('status', 'published') : Promise.resolve({
        data: []
      }),
      contentByType.testimonials ? supabaseClient.from('testimonials').select('*').in('id', contentByType.testimonials).eq('status', 'published') : Promise.resolve({
        data: []
      }),
      contentByType.faqs ? supabaseClient.from('faqs').select('*').in('id', contentByType.faqs).eq('status', 'published') : Promise.resolve({
        data: []
      })
    ]);
    return {
      articles: articles.data || [],
      videos: videos.data || [],
      testimonials: testimonials.data || [],
      faqs: faqs.data || [],
      has_specific_content: true
    };
  } catch (error) {
    console.error('‚ùå Error obteniendo contenido espec√≠fico:', error);
    return null;
  }
}
async function getDefaultRelatedContent(supabaseClient) {
  try {
    const [articles, videos, faqs, testimonials] = await Promise.all([
      supabaseClient.from('articles').select('*').eq('status', 'published').order('published_at', {
        ascending: false
      }).limit(5),
      supabaseClient.from('videos').select('*').eq('status', 'published').order('published_at', {
        ascending: false
      }).limit(4),
      supabaseClient.from('faqs').select('*').eq('status', 'published').order('sort_order').limit(6),
      supabaseClient.from('testimonials').select('*').eq('status', 'published').order('published_at', {
        ascending: false
      }).limit(3)
    ]);
    return {
      articles: articles.data || [],
      videos: videos.data || [],
      testimonials: testimonials.data || [],
      faqs: faqs.data || []
    };
  } catch (error) {
    console.error('‚ùå Error obteniendo contenido por defecto:', error);
    return {
      articles: [],
      videos: [],
      testimonials: [],
      faqs: []
    };
  }
}
function combineSpecificAndGeneralContent(specificContent, defaultContent) {
  if (!specificContent || !specificContent.has_specific_content) {
    return {
      ...defaultContent,
      content_source: 'general_only'
    };
  }
  return {
    articles: [
      ...specificContent.articles,
      ...defaultContent.articles.slice(0, Math.max(0, 5 - specificContent.articles.length))
    ],
    videos: [
      ...specificContent.videos,
      ...defaultContent.videos.slice(0, Math.max(0, 4 - specificContent.videos.length))
    ],
    testimonials: [
      ...specificContent.testimonials,
      ...defaultContent.testimonials.slice(0, Math.max(0, 3 - specificContent.testimonials.length))
    ],
    faqs: [
      ...specificContent.faqs,
      ...defaultContent.faqs.slice(0, Math.max(0, 6 - specificContent.faqs.length))
    ],
    content_source: 'specific_and_general'
  };
}
// =====================================================
// FUNCIONES AUXILIARES (EXISTENTES)
// =====================================================
function parseUrlToSlugs(pathname) {
  const systemRoutes = [
    '/property-search',
    '/api',
    '/functions',
    '/_app',
    '/admin'
  ];
  if (systemRoutes.some((route)=>pathname.startsWith(route))) {
    return [];
  }
  return pathname.replace(/^\//, '').split('/').filter((segment)=>segment.length > 0).map((segment)=>segment.toLowerCase().trim());
}
// =====================================================
// ‚ú® NUEVA FUNCI√ìN DE BREADCRUMBS
// =====================================================
/**
 * Genera breadcrumbs estructurados siguiendo el patr√≥n:
 * inicio ‚Üí operaci√≥n ‚Üí categor√≠a ‚Üí ciudad ‚Üí sector [‚Üí otros tags de la URL]
 */ async function generateSmartBreadcrumbs(supabaseClient, tags, urlSegments, context = 'listing') {
  console.log('üçû === GENERANDO BREADCRUMBS INTELIGENTES ===');
  console.log('üìã Context:', context);
  console.log('üè∑Ô∏è Tags recibidos:', tags?.length || 0);
  console.log('üìé URL segments:', urlSegments);
  const breadcrumbs = [];
  // 1. INICIO siempre es el primer elemento
  breadcrumbs.push({
    name: 'Inicio',
    slug: '',
    url: '/',
    category: 'root',
    is_active: false,
    position: 0
  });
  if (!tags || tags.length === 0) {
    console.log('‚ö†Ô∏è No hay tags, retornando solo breadcrumb de inicio');
    return breadcrumbs;
  }
  // 2. Organizar tags por categor√≠a con prioridad espec√≠fica
  const tagsByCategory = {
    operacion: tags.filter((t)=>t.category === 'operacion'),
    categoria: tags.filter((t)=>t.category === 'categoria'),
    ciudad: tags.filter((t)=>t.category === 'ciudad'),
    sector: tags.filter((t)=>t.category === 'sector'),
    provincia: tags.filter((t)=>t.category === 'provincia'),
    otros: tags.filter((t)=>![
        'operacion',
        'categoria',
        'ciudad',
        'sector',
        'provincia'
      ].includes(t.category))
  };
  console.log('üìä Tags organizados por categor√≠a:', {
    operacion: tagsByCategory.operacion.length,
    categoria: tagsByCategory.categoria.length,
    ciudad: tagsByCategory.ciudad.length,
    sector: tagsByCategory.sector.length,
    provincia: tagsByCategory.provincia.length,
    otros: tagsByCategory.otros.length
  });
  // 3. Construcci√≥n progresiva de breadcrumbs siguiendo el patr√≥n jer√°rquico
  const hierarchyOrder = [
    'operacion',
    'categoria',
    'ciudad',
    'sector'
  ];
  let currentPath = '';
  let position = 1;
  // Para single property/project, limitamos a los 4 pilares principales
  const maxDepth = context === 'single' ? hierarchyOrder.length : hierarchyOrder.length + 2;
  for (const categoryKey of hierarchyOrder){
    const categoryTags = tagsByCategory[categoryKey];
    if (categoryTags.length > 0) {
      // Tomar el primer tag de esta categor√≠a (el m√°s relevante)
      const tag = categoryTags[0];
      // Construir la URL acumulativa
      currentPath = currentPath ? `${currentPath}/${tag.slug}` : tag.slug;
      breadcrumbs.push({
        name: tag.display_name || tag.name,
        slug: tag.slug,
        url: `/${currentPath}`,
        category: tag.category,
        is_active: false,
        position: position,
        tag_id: tag.id,
        description: tag.description,
        icon: tag.icon
      });
      position++;
      console.log(`‚úÖ Agregado breadcrumb ${categoryKey}: ${tag.name} ‚Üí /${currentPath}`);
    }
  }
  // 4. Para listados, agregar tags adicionales de la URL que no est√©n en los pilares principales
  if (context === 'listing' && tagsByCategory.otros.length > 0) {
    console.log('üìé Agregando tags adicionales para listado...');
    // Filtrar tags que ya est√°n en la URL pero no en los pilares principales
    const additionalTags = tagsByCategory.otros.filter((tag)=>urlSegments.includes(tag.slug)).slice(0, 2); // M√°ximo 2 tags adicionales para no sobrecargar
    for (const tag of additionalTags){
      currentPath = `${currentPath}/${tag.slug}`;
      breadcrumbs.push({
        name: tag.display_name || tag.name,
        slug: tag.slug,
        url: `/${currentPath}`,
        category: tag.category,
        is_active: false,
        position: position,
        tag_id: tag.id,
        description: tag.description,
        icon: tag.icon
      });
      position++;
      console.log(`‚úÖ Agregado tag adicional: ${tag.name} ‚Üí /${currentPath}`);
    }
  }
  // 5. Marcar el √∫ltimo elemento como activo (p√°gina actual)
  if (breadcrumbs.length > 1) {
    breadcrumbs[breadcrumbs.length - 1].is_active = true;
  }
  // 6. Validar y limpiar breadcrumbs
  const validBreadcrumbs = breadcrumbs.filter((bc)=>bc.name && bc.name.trim().length > 0);
  console.log('‚úÖ === BREADCRUMBS GENERADOS EXITOSAMENTE ===');
  console.log('üìä Resumen:', {
    total_breadcrumbs: validBreadcrumbs.length,
    context: context,
    final_url: validBreadcrumbs[validBreadcrumbs.length - 1]?.url,
    structure: validBreadcrumbs.map((bc)=>`${bc.category}:${bc.name}`).join(' ‚Üí ')
  });
  return validBreadcrumbs;
}
/**
 * Funci√≥n auxiliar para obtener breadcrumbs para propiedades individuales
 * Toma los tags de la propiedad y genera breadcrumbs b√°sicos
 */ async function generatePropertyBreadcrumbs(supabaseClient, property) {
  console.log('üè† Generando breadcrumbs para propiedad individual:', property.name);
  try {
    // Obtener tags de la propiedad
    const propertyTags = await getPropertyTags(supabaseClient, property.id);
    if (propertyTags.length === 0) {
      // Breadcrumbs m√≠nimos basados en datos de la propiedad
      return await generateFallbackPropertyBreadcrumbs(property);
    }
    // Generar breadcrumbs usando los tags de la propiedad
    const breadcrumbs = await generateSmartBreadcrumbs(supabaseClient, propertyTags, [], 'single');
    // Agregar la propiedad como elemento final
    const lastBreadcrumb = breadcrumbs[breadcrumbs.length - 1];
    const finalUrl = lastBreadcrumb ? `${lastBreadcrumb.url}/${property.slug_url || property.id}` : `/${property.slug_url || property.id}`;
    breadcrumbs.push({
      name: property.name,
      slug: property.slug_url || property.id,
      url: finalUrl,
      category: 'property',
      is_active: true,
      position: breadcrumbs.length,
      is_current_page: true
    });
    console.log('‚úÖ Breadcrumbs de propiedad generados:', breadcrumbs.length);
    return breadcrumbs;
  } catch (error) {
    console.error('‚ùå Error generando breadcrumbs de propiedad:', error);
    return await generateFallbackPropertyBreadcrumbs(property);
  }
}
/**
 * Breadcrumbs de fallback para propiedades sin tags suficientes
 */ async function generateFallbackPropertyBreadcrumbs(property) {
  const breadcrumbs = [
    {
      name: 'Inicio',
      slug: '',
      url: '/',
      category: 'root',
      is_active: false,
      position: 0
    }
  ];
  // Agregar categor√≠a si est√° disponible
  if (property.property_categories?.name) {
    const categorySlug = property.property_categories.name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9\-]/g, '');
    breadcrumbs.push({
      name: property.property_categories.name,
      slug: categorySlug,
      url: `/${categorySlug}`,
      category: 'categoria',
      is_active: false,
      position: 1
    });
  }
  // Agregar ubicaci√≥n si est√° disponible
  if (property.cities?.name) {
    const citySlug = property.cities.name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9\-]/g, '');
    const previousUrl = breadcrumbs[breadcrumbs.length - 1].url;
    const cityUrl = previousUrl === '/' ? `/${citySlug}` : `${previousUrl}/${citySlug}`;
    breadcrumbs.push({
      name: property.cities.name,
      slug: citySlug,
      url: cityUrl,
      category: 'ciudad',
      is_active: false,
      position: breadcrumbs.length
    });
  }
  // Agregar la propiedad como elemento final
  const lastBreadcrumb = breadcrumbs[breadcrumbs.length - 1];
  const finalUrl = `${lastBreadcrumb.url}/${property.slug_url || property.id}`;
  breadcrumbs.push({
    name: property.name,
    slug: property.slug_url || property.id,
    url: finalUrl,
    category: 'property',
    is_active: true,
    position: breadcrumbs.length,
    is_current_page: true
  });
  console.log('‚úÖ Breadcrumbs fallback generados para propiedad');
  return breadcrumbs;
}
async function findTagsBySlug(supabaseClient, slugs) {
  if (slugs.length === 0) return [];
  const { data: tags, error } = await supabaseClient.from('tags').select('id, name, slug, category').in('slug', slugs);
  if (error) {
    console.error('Error buscando tags:', error);
    return [];
  }
  return tags || [];
}
function extractLocationFromTags(tags) {
  const locationTag = tags?.find((tag)=>tag.category === 'ciudad' || tag.category === 'sector' || tag.category === 'provincia');
  return locationTag?.name || null;
}
function extractPropertyTypeFromTags(tags) {
  const typeTag = tags?.find((tag)=>tag.category === 'categoria');
  return typeTag?.name || null;
}
function extractOperationFromTags(tags) {
  const operationTag = tags?.find((tag)=>tag.category === 'operacion');
  return operationTag?.name || null;
}
// =====================================================
// FUNCI√ìN PRINCIPAL INTEGRADA
// =====================================================
Deno.serve(async (req)=>{
  if (req.method === 'OPTIONS') {
    return new Response('ok', {
      headers: corsHeaders
    });
  }
  try {
    const supabase = createClient('https://pacewqgypevfgjmdsorz.supabase.co', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBhY2V3cWd5cGV2ZmdqbWRzb3J6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg2NjU4OTksImV4cCI6MjA2NDI0MTg5OX0.Qlg-UVy-sikr76GxYmTcfCz1EnAqPHxvFeLrdqnjuWs');
    const url = new URL(req.url);
    const pathname = url.pathname;
    // Extraer slug despu√©s de 'busqueda/'
    const pathSegments = pathname.split('/').filter((segment)=>segment.length > 0);
    const busquedaIndex = pathSegments.findIndex((segment)=>segment === 'busqueda');
    let slug = '';
    if (busquedaIndex !== -1 && busquedaIndex < pathSegments.length - 1) {
      slug = pathSegments.slice(busquedaIndex + 1).join('/');
    } else {
      slug = url.searchParams.get('url') || url.searchParams.get('slug') || '';
    }
    const refParam = url.searchParams.get('ref');
    const page = parseInt(url.searchParams.get('page')) || 1;
    const limit = parseInt(url.searchParams.get('limit')) || 30;
    if (!slug) {
      return new Response(JSON.stringify({
        error: 'Invalid URL format. Expected: /function-name/busqueda/your-slug-here',
        type: 'error',
        received_path: pathname
      }), {
        status: 400,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    console.log('üîç Iniciando b√∫squeda unificada:', {
      slug,
      refParam,
      page,
      limit
    });
    // Obtener usuario referido si existe
    let referralAgent = null;
    if (refParam) {
      referralAgent = await getReferralAgent(supabase, refParam);
    }
    // PASO 1: Intentar b√∫squeda por slug_url (propiedad individual)
    const propertyResult = await searchPropertyBySlugUrl(supabase, slug);
    if (propertyResult.found && propertyResult.property) {
      console.log('‚úÖ Encontrada como propiedad individual');
      const property = propertyResult.property;
      // Procesar propiedad
      const optimizedProperty = optimizePropertyImages(unifyPropertyPricing(property));
      // ‚ú® INTEGRACI√ìN: Obtener propiedades similares con el nuevo sistema
      console.log('üè† Obteniendo propiedades similares...');
      const propertyTags = await getPropertyTags(supabase, property.id);
      const similarProperties = await getSmartSimilarProperties(supabase, propertyTags, property.id);
      // Obtener datos relacionados en paralelo
      const [specificContent, defaultContent, projectDetails, agentData, googlePlacesData] = await Promise.all([
        getPropertySpecificContent(supabase, property.id),
        getDefaultRelatedContent(supabase),
        property.is_project && property.project_detail_id ? getCompleteProjectDetails(supabase, property.project_detail_id) : Promise.resolve(null),
        property.agent_id ? getPropertyAgent(supabase, property.agent_id) : Promise.resolve(null),
        property.sectors?.name || property.cities?.name ? getLocationGooglePlacesData(supabase, property.sectors?.name || property.cities?.name) : Promise.resolve(null)
      ]);
      const relatedContent = combineSpecificAndGeneralContent(specificContent, defaultContent);
      const responseType = property.is_project ? 'single-property-project' : 'single-property';
      const seoData = generateSEOMetadata({
        type: responseType,
        property: optimizedProperty,
        urlSegments: [
          slug
        ],
        googlePlacesData
      });
      const response = {
        type: responseType,
        available: property.property_status === 'Publicada',
        property: optimizedProperty,
        relatedContent,
        projectDetails: projectDetails || null,
        agent: formatAgent(agentData, 'agent') || null,
        referralAgent: formatAgent(referralAgent, 'referral') || null,
        // ‚ú® NUEVA SECCI√ìN: Propiedades similares integradas
        similarProperties: similarProperties,
        similarPropertiesDebug: {
          total_found: similarProperties.length,
          tags_used: propertyTags.length,
          search_method: propertyTags.length > 0 ? 'smart_tags' : 'fallback'
        },
        // ‚ú® NUEVA SECCI√ìN: Breadcrumbs para propiedad individual
        breadcrumbs: await generatePropertyBreadcrumbs(supabase, property),
        seo: seoData,
        meta: {
          slug,
          searchPath: pathname,
          referralParam: refParam,
          timestamp: new Date().toISOString()
        }
      };
      return new Response(JSON.stringify(response), {
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json',
          'Cache-Control': 'public, max-age=3600'
        }
      });
    }
    // PASO 2: B√∫squeda por tags (listado de propiedades)
    console.log('üîç Procesando como listado por tags');
    const urlSegments = parseUrlToSlugs(slug);
    const tags = await findTagsBySlug(supabase, urlSegments);
    const tagIds = tags.map((t)=>t.id);
    console.log('üè∑Ô∏è Tags encontrados:', {
      slugs: urlSegments,
      tagCount: tags.length
    });
    // B√∫squeda con paginaci√≥n
    const searchResults = await searchPropertiesByTags(supabase, tagIds, page, limit);
    // Procesar propiedades en paralelo
    console.log('üîÑ Procesando propiedades...');
    const enrichedProperties = await Promise.all((searchResults.properties || []).map(async (property)=>{
      const optimizedProperty = optimizePropertyImages(unifyPropertyPricing(property));
      const [projectDetails, agentData] = await Promise.all([
        property.is_project && property.project_detail_id ? getCompleteProjectDetails(supabase, property.project_detail_id) : Promise.resolve(null),
        property.agent_id ? getPropertyAgent(supabase, property.agent_id) : Promise.resolve(null)
      ]);
      return {
        ...optimizedProperty,
        projectDetails: projectDetails || null,
        agent: formatAgent(agentData, 'agent') || null
      };
    }));
    // Obtener contenido relacionado y datos de Google Places
    const [relatedContent, googlePlacesData] = await Promise.all([
      getDefaultRelatedContent(supabase),
      extractLocationFromTags(tags) ? getLocationGooglePlacesData(supabase, extractLocationFromTags(tags)) : Promise.resolve(null)
    ]);
    const seoData = generateSEOMetadata({
      type: 'property-list',
      searchResults: {
        properties: enrichedProperties,
        pagination: {
          currentPage: searchResults.currentPage,
          totalCount: searchResults.totalCount,
          itemsPerPage: searchResults.itemsPerPage,
          totalPages: Math.ceil(searchResults.totalCount / searchResults.itemsPerPage),
          hasMore: searchResults.hasMore
        }
      },
      tags,
      urlSegments,
      googlePlacesData
    });
    const response = {
      type: 'property-list',
      available: true,
      searchResults: {
        properties: enrichedProperties,
        tags,
        searchTerms: urlSegments,
        pagination: {
          currentPage: searchResults.currentPage,
          totalCount: searchResults.totalCount,
          itemsPerPage: searchResults.itemsPerPage,
          totalPages: Math.ceil(searchResults.totalCount / searchResults.itemsPerPage),
          hasMore: searchResults.hasMore,
          hasNextPage: searchResults.hasMore,
          hasPreviousPage: searchResults.currentPage > 1
        }
      },
      relatedContent,
      referralAgent: formatAgent(referralAgent, 'referral') || null,
      // ‚ú® NUEVA SECCI√ìN: Breadcrumbs para listado de propiedades
      breadcrumbs: await generateSmartBreadcrumbs(supabase, tags, urlSegments, 'listing'),
      seo: seoData,
      meta: {
        slug,
        searchPath: pathname,
        urlSegments,
        referralParam: refParam,
        page,
        limit,
        timestamp: new Date().toISOString()
      }
    };
    return new Response(JSON.stringify(response), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
        'Cache-Control': 'public, max-age=1800'
      }
    });
  } catch (error) {
    console.error('Edge function error:', error);
    return new Response(JSON.stringify({
      error: 'Internal server error',
      type: 'error',
      details: error.message
    }), {
      status: 500,
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  }
});
