import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type'
};
// =====================================================
// FUNCIONES SEO CON GOOGLE PLACES INTEGRATION (EXISTENTES)
// =====================================================
const googlePlacesCache = new Map();
async function getLocationGooglePlacesData(supabaseClient, locationName) {
  if (!locationName) return null;
  if (googlePlacesCache.has(locationName)) {
    console.log(`üéØ Cache hit para Google Places: ${locationName}`);
    return googlePlacesCache.get(locationName);
  }
  console.log(`üîç Obteniendo datos de Google Places para: ${locationName}`);
  try {
    const { data: locationInsight, error: locationError } = await supabaseClient.from('location_insights_with_places').select('id, location_name, services_score').ilike('location_name', `%${locationName}%`).eq('status', 'active').single();
    if (locationError || !locationInsight) {
      console.log(`‚ö†Ô∏è No se encontr√≥ location_insight para: ${locationName}`);
      return null;
    }
    const { data: placesData, error: placesError } = await supabaseClient.from('google_places_data').select(`
        place_name, place_category, place_type, rating, 
        user_ratings_total, distance_display, business_status,
        is_featured, relevance_score, address
      `).eq('location_insight_id', locationInsight.id).eq('status', 'active').order('distance_meters', {
      ascending: true
    });
    if (placesError) {
      console.error(`‚ùå Error obteniendo Google Places data:`, placesError);
      return null;
    }
    const placesByCategory = {};
    const featuredPlaces = [];
    (placesData || []).forEach((place)=>{
      if (!placesByCategory[place.place_category]) {
        placesByCategory[place.place_category] = [];
      }
      placesByCategory[place.place_category].push(place);
      if (place.is_featured && featuredPlaces.length < 10) {
        featuredPlaces.push(place);
      }
    });
    const stats = {
      total_places: placesData?.length || 0,
      categories_count: Object.keys(placesByCategory).length,
      featured_count: featuredPlaces.length,
      avg_rating: placesData?.length > 0 ? (placesData.filter((p)=>p.rating).reduce((sum, p)=>sum + p.rating, 0) / placesData.filter((p)=>p.rating).length).toFixed(1) : null,
      services_score: locationInsight.services_score || 0
    };
    const result = {
      location_insight_id: locationInsight.id,
      location_name: locationInsight.location_name,
      places_by_category: placesByCategory,
      featured_places: featuredPlaces,
      stats
    };
    googlePlacesCache.set(locationName, result);
    setTimeout(()=>googlePlacesCache.delete(locationName), 30 * 60 * 1000);
    return result;
  } catch (error) {
    console.error(`‚ùå Error cr√≠tico obteniendo Google Places data:`, error);
    return null;
  }
}
function optimizePropertyImages(property) {
  const location = property.sectors?.name || property.cities?.name || '';
  const propertyType = property.property_categories?.name || 'Propiedad';
  const allImages = new Map();
  if (property.main_image_url && property.main_image_url.trim()) {
    allImages.set(property.main_image_url, {
      url: property.main_image_url,
      title: `${property.name} - Imagen Principal`,
      description: `${propertyType} de ${property.bedrooms} habitaciones en ${location}`,
      is_main: true,
      sort_order: 0,
      source: 'main'
    });
  }
  if (property.property_images && property.property_images.length > 0) {
    property.property_images.forEach((img, index)=>{
      if (img.url && img.url.trim()) {
        const key = img.url;
        if (!allImages.has(key)) {
          allImages.set(key, {
            url: img.url,
            title: img.title || `${property.name} - Vista ${index + 1}`,
            description: img.description || `${propertyType} en ${location}`,
            is_main: img.is_main || false,
            sort_order: img.sort_order || index + 1,
            source: 'property_images'
          });
        }
      }
    });
  }
  if (property.gallery_images_url && typeof property.gallery_images_url === 'string') {
    const galleryUrls = property.gallery_images_url.split(',').map((url)=>url.trim()).filter((url)=>url.length > 0 && url !== ',');
    galleryUrls.forEach((url, index)=>{
      if (!allImages.has(url)) {
        allImages.set(url, {
          url: url,
          title: `${property.name} - Galer√≠a ${index + 1}`,
          description: `${propertyType} en ${location}`,
          is_main: false,
          sort_order: 100 + index,
          source: 'gallery'
        });
      }
    });
  }
  const unifiedImages = Array.from(allImages.values()).sort((a, b)=>{
    if (a.is_main && !b.is_main) return -1;
    if (!a.is_main && b.is_main) return 1;
    return a.sort_order - b.sort_order;
  }).map((img, index)=>({
      ...img,
      optimized_url: `${img.url}?w=800&h=600&q=85&f=webp`,
      thumbnail_url: `${img.url}?w=300&h=200&q=80&f=webp`,
      position: index
    }));
  const mainImage = unifiedImages.find((img)=>img.is_main) || unifiedImages[0];
  return {
    ...property,
    main_image_optimized: mainImage ? {
      url: mainImage.url,
      alt: mainImage.title,
      width: 800,
      height: 600,
      optimized_url: mainImage.optimized_url
    } : null,
    images_unified: unifiedImages,
    images_count: unifiedImages.length
  };
}
function unifyPropertyPricing(property) {
  const prices = {
    sale: null,
    rental: null,
    temp_rental: null,
    furnished_rental: null,
    display_price: null,
    price_range: null
  };
  if (property.sale_price && property.sale_price > 0) {
    prices.sale = {
      amount: property.sale_price,
      currency: property.sale_currency || 'USD',
      formatted: `$${property.sale_price.toLocaleString()} ${property.sale_currency || 'USD'}`
    };
  }
  if (property.rental_price && property.rental_price > 0) {
    prices.rental = {
      amount: property.rental_price,
      currency: property.rental_currency || 'USD',
      formatted: `$${property.rental_price.toLocaleString()} ${property.rental_currency || 'USD'}/mes`
    };
  }
  if (property.temp_rental_price && property.temp_rental_price > 0) {
    prices.temp_rental = {
      amount: property.temp_rental_price,
      currency: property.temp_rental_currency || 'USD',
      formatted: `$${property.temp_rental_price.toLocaleString()} ${property.temp_rental_currency || 'USD'}/noche`
    };
  }
  if (property.furnished_rental_price && property.furnished_rental_price > 0) {
    prices.furnished_rental = {
      amount: property.furnished_rental_price,
      currency: property.furnished_rental_currency || 'USD',
      formatted: `$${property.furnished_rental_price.toLocaleString()} ${property.furnished_rental_currency || 'USD'}/mes amueblado`
    };
  }
  if (prices.sale) {
    prices.display_price = prices.sale;
    prices.operation_type = 'sale';
  } else if (prices.rental) {
    prices.display_price = prices.rental;
    prices.operation_type = 'rental';
  } else if (prices.furnished_rental) {
    prices.display_price = prices.furnished_rental;
    prices.operation_type = 'furnished_rental';
  } else if (prices.temp_rental) {
    prices.display_price = prices.temp_rental;
    prices.operation_type = 'temp_rental';
  }
  return {
    ...property,
    pricing_unified: prices
  };
}
// =====================================================
// ‚ú® NUEVAS FUNCIONES PARA COORDENADAS
// =====================================================
function parseCoordinates(coordinatesData) {
  if (!coordinatesData) return null;
  try {
    // Si es un string, intentar parsearlo
    if (typeof coordinatesData === 'string') {
      // Formato POINT(lng lat) de PostGIS
      if (coordinatesData.includes('POINT')) {
        const match = coordinatesData.match(/POINT\s*\(\s*([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s*\)/i);
        if (match) {
          return {
            lng: parseFloat(match[1]),
            lat: parseFloat(match[2])
          };
        }
      }
      // Intentar parsear como JSON
      const parsed = JSON.parse(coordinatesData);
      if (parsed.x !== undefined && parsed.y !== undefined) {
        return {
          lng: parsed.x,
          lat: parsed.y
        };
      }
      if (parsed.lng !== undefined && parsed.lat !== undefined) {
        return {
          lng: parsed.lng,
          lat: parsed.lat
        };
      }
      if (parsed.longitude !== undefined && parsed.latitude !== undefined) {
        return {
          lng: parsed.longitude,
          lat: parsed.latitude
        };
      }
    }
    // Si es un objeto
    if (typeof coordinatesData === 'object') {
      if (coordinatesData.x !== undefined && coordinatesData.y !== undefined) {
        return {
          lng: coordinatesData.x,
          lat: coordinatesData.y
        };
      }
      if (coordinatesData.lng !== undefined && coordinatesData.lat !== undefined) {
        return {
          lng: coordinatesData.lng,
          lat: coordinatesData.lat
        };
      }
      if (coordinatesData.longitude !== undefined && coordinatesData.latitude !== undefined) {
        return {
          lng: coordinatesData.longitude,
          lat: coordinatesData.latitude
        };
      }
    }
    console.warn('‚ö†Ô∏è Formato de coordenadas no reconocido:', coordinatesData);
    return null;
  } catch (error) {
    console.error('‚ùå Error parseando coordenadas:', error, coordinatesData);
    return null;
  }
}
function getStaticCoordinates(property) {
  // Mantener el sistema est√°tico existente como √∫ltimo fallback
  const locationMap = {
    'punta cana': {
      lat: 18.5601,
      lng: -68.3725
    },
    'bavaro': {
      lat: 18.5467,
      lng: -68.4104
    },
    'naco': {
      lat: 18.4861,
      lng: -69.9312
    },
    'piantini': {
      lat: 18.4745,
      lng: -69.9254
    },
    'bella vista': {
      lat: 18.4696,
      lng: -69.9411
    },
    'manoguayabo': {
      lat: 18.4861,
      lng: -70.0037
    },
    'santiago': {
      lat: 19.4517,
      lng: -70.6970
    },
    'distrito nacional': {
      lat: 18.4682,
      lng: -69.9279
    }
  };
  const searchTerms = [
    property.sectors?.name?.toLowerCase(),
    property.cities?.name?.toLowerCase()
  ].filter(Boolean);
  for (const term of searchTerms){
    for (const [location, coords] of Object.entries(locationMap)){
      if (term.includes(location) || location.includes(term)) {
        return coords;
      }
    }
  }
  // Default: Distrito Nacional
  return {
    lat: 18.4682,
    lng: -69.9279
  };
}
function findFallbackCoordinates(property) {
  // Buscar coordenadas de zona cuando no se debe mostrar ubicaci√≥n exacta
  if (property.sectors?.coordinates) {
    return parseCoordinates(property.sectors.coordinates);
  }
  if (property.cities?.coordinates) {
    return parseCoordinates(property.cities.coordinates);
  }
  if (property.cities?.provinces?.coordinates) {
    return parseCoordinates(property.cities.provinces.coordinates);
  }
  return getStaticCoordinates(property);
}
function processPropertyCoordinates(property) {
  console.log('üìç === PROCESANDO COORDENADAS DE PROPIEDAD ===');
  console.log('üè† Property ID:', property.id);
  console.log('üìç exact_coordinates:', property.exact_coordinates);
  console.log('üëÅÔ∏è show_exact_location:', property.show_exact_location);
  console.log('üèôÔ∏è sectors.coordinates:', property.sectors?.coordinates);
  console.log('üåÜ cities.coordinates:', property.cities?.coordinates);
  console.log('üó∫Ô∏è provinces.coordinates:', property.cities?.provinces?.coordinates);
  const result = {
    hasExactCoordinates: false,
    showExactLocation: property.show_exact_location || false,
    exactCoordinates: null,
    fallbackCoordinates: null,
    source: 'none',
    processed: true,
    rawData: {
      exact_coordinates: property.exact_coordinates,
      show_exact_location: property.show_exact_location,
      sectors_coordinates: property.sectors?.coordinates,
      cities_coordinates: property.cities?.coordinates,
      provinces_coordinates: property.cities?.provinces?.coordinates
    }
  };
  // ‚úÖ PRIORIDAD 1: COORDENADAS EXACTAS DE LA PROPIEDAD
  if (property.exact_coordinates) {
    console.log('üéØ Usando coordenadas exactas de la propiedad');
    result.hasExactCoordinates = true;
    result.exactCoordinates = parseCoordinates(property.exact_coordinates);
    result.source = 'property_exact';
    // Si no se debe mostrar ubicaci√≥n exacta, usar coordenadas de zona como fallback
    if (!property.show_exact_location) {
      console.log('üëÅÔ∏è show_exact_location = false, buscando coordenadas de zona...');
      result.fallbackCoordinates = findFallbackCoordinates(property);
    }
  } else if (property.sectors?.coordinates) {
    console.log('üèòÔ∏è Usando coordenadas del sector');
    result.fallbackCoordinates = parseCoordinates(property.sectors.coordinates);
    result.source = 'sector';
  } else if (property.cities?.coordinates) {
    console.log('üèôÔ∏è Usando coordenadas de la ciudad');
    result.fallbackCoordinates = parseCoordinates(property.cities.coordinates);
    result.source = 'city';
  } else if (property.cities?.provinces?.coordinates) {
    console.log('üó∫Ô∏è Usando coordenadas de la provincia');
    result.fallbackCoordinates = parseCoordinates(property.cities.provinces.coordinates);
    result.source = 'province';
  } else {
    console.log('üìç Usando coordenadas est√°ticas como fallback');
    result.fallbackCoordinates = getStaticCoordinates(property);
    result.source = 'static_fallback';
  }
  console.log('‚úÖ Coordenadas procesadas exitosamente:', {
    hasExact: result.hasExactCoordinates,
    showExact: result.showExactLocation,
    source: result.source,
    exactCoords: result.exactCoordinates,
    fallbackCoords: result.fallbackCoordinates
  });
  return result;
}
function generateLocationData(property, coordinatesInfo) {
  console.log('üó∫Ô∏è === GENERANDO DATOS DE UBICACI√ìN COMPLETOS ===');
  const displayCoordinates = coordinatesInfo.showExactLocation && coordinatesInfo.exactCoordinates ? coordinatesInfo.exactCoordinates : coordinatesInfo.fallbackCoordinates;
  const locationData = {
    // ‚úÖ COORDENADAS PARA MOSTRAR (respetando show_exact_location)
    coordinates: displayCoordinates,
    // ‚úÖ INFORMACI√ìN DE CONFIGURACI√ìN
    hasExactCoordinates: coordinatesInfo.hasExactCoordinates,
    showExactLocation: coordinatesInfo.showExactLocation,
    coordinatesSource: coordinatesInfo.source,
    // ‚úÖ DATOS SEPARADOS PARA CASOS ESPEC√çFICOS
    exactCoordinates: coordinatesInfo.exactCoordinates,
    fallbackCoordinates: coordinatesInfo.fallbackCoordinates,
    // ‚úÖ INFORMACI√ìN DE UBICACI√ìN TEXTUAL
    address: formatLocationAddress(property),
    sector: property.sectors?.name || null,
    city: property.cities?.name || null,
    province: property.cities?.provinces?.name || null,
    // ‚úÖ CONFIGURACI√ìN PARA MAPAS
    mapConfig: {
      zoom: coordinatesInfo.showExactLocation && coordinatesInfo.hasExactCoordinates ? 17 : 14,
      showMarker: coordinatesInfo.showExactLocation && coordinatesInfo.hasExactCoordinates,
      showAreaCircle: !coordinatesInfo.showExactLocation,
      circleRadius: coordinatesInfo.source === 'sector' ? 500 : coordinatesInfo.source === 'city' ? 1000 : coordinatesInfo.source === 'province' ? 2000 : 750
    },
    // ‚úÖ METADATA PARA DEBUG
    debug: {
      rawCoordinatesData: coordinatesInfo.rawData,
      processingSource: coordinatesInfo.source,
      hasExactButHidden: coordinatesInfo.hasExactCoordinates && !coordinatesInfo.showExactLocation,
      fallbackReason: !coordinatesInfo.hasExactCoordinates ? 'no_exact_coordinates' : !coordinatesInfo.showExactLocation ? 'privacy_setting' : null
    }
  };
  console.log('‚úÖ Datos de ubicaci√≥n generados:', {
    hasCoordinates: !!locationData.coordinates,
    source: locationData.coordinatesSource,
    showExact: locationData.showExactLocation,
    zoom: locationData.mapConfig.zoom,
    showMarker: locationData.mapConfig.showMarker
  });
  return locationData;
}
function formatLocationAddress(property) {
  const parts = [
    property.sectors?.name,
    property.cities?.name,
    property.cities?.provinces?.name
  ].filter(Boolean);
  return parts.length > 0 ? parts.join(', ') : 'Rep√∫blica Dominicana';
}
function generateSEOMetadata(context) {
  const { type, searchResults, property, tags, urlSegments, googlePlacesData } = context;
  let seoData = {
    title: '',
    description: '',
    keywords: [],
    h1: '',
    structured_data: {},
    og: {},
    twitter: {},
    technical: {},
    places_enrichment: null
  };
  if (type === 'single-property' || type === 'single-property-project' || type === 'property-not-available') {
    const prop = property;
    const location = prop.sectors?.name || prop.cities?.name || 'Rep√∫blica Dominicana';
    const propertyType = prop.property_categories?.name || 'Propiedad';
    const pricing = prop.pricing_unified?.display_price;
    const price = pricing ? pricing.formatted : 'Precio disponible';
    let nearbyServices = '';
    if (googlePlacesData && googlePlacesData.featured_places?.length > 0) {
      const topServices = googlePlacesData.featured_places.slice(0, 3);
      nearbyServices = ` Cerca de ${topServices.map((s)=>s.place_name).join(', ')}.`;
    }
    // T√≠tulo espec√≠fico para propiedades no disponibles
    if (type === 'property-not-available') {
      seoData.title = `${prop.name} - No Disponible | Propiedades Similares | CLIC Inmobiliaria`;
      seoData.description = `${propertyType} en ${location} ya no est√° disponible. Descubre propiedades similares de ${prop.bedrooms} habitaciones y ${prop.bathrooms} ba√±os.${nearbyServices}`;
    } else {
      seoData.title = `${prop.name} | ${propertyType} en ${location} | CLIC Inmobiliaria`;
      seoData.description = `${propertyType} de ${prop.bedrooms} habitaciones y ${prop.bathrooms} ba√±os en ${location}. ${price}. ${prop.built_area}m¬≤.${nearbyServices} Ver fotos y detalles.`;
    }
    seoData.h1 = prop.name;
    seoData.keywords = [
      `${propertyType.toLowerCase()} ${location.toLowerCase()}`,
      `${prop.bedrooms} habitaciones ${location.toLowerCase()}`,
      `comprar ${propertyType.toLowerCase()} ${location.toLowerCase()}`,
      'bienes raices republica dominicana'
    ];
    if (googlePlacesData) {
      const serviceKeywords = Object.keys(googlePlacesData.places_by_category).map((category)=>`cerca de ${category.replace('_', ' ')}`).slice(0, 3);
      seoData.keywords.push(...serviceKeywords);
    }
    seoData.structured_data = {
      "@context": "https://schema.org",
      "@type": "RealEstateListing",
      "name": prop.name,
      "description": seoData.description,
      "url": `https://clic.do/${prop.slug_url}`,
      "image": [
        prop.main_image_optimized?.url
      ].filter(Boolean),
      "offers": {
        "@type": "Offer",
        "price": pricing?.amount,
        "priceCurrency": pricing?.currency,
        "availability": type === 'property-not-available' ? "OutOfStock" : prop.property_status === 'Publicada' ? "InStock" : "OutOfStock"
      },
      "address": {
        "@type": "PostalAddress",
        "addressLocality": location,
        "addressCountry": "DO"
      },
      "floorSize": {
        "@type": "QuantitativeValue",
        "value": prop.built_area,
        "unitCode": "MTK"
      },
      "numberOfRooms": prop.bedrooms,
      "numberOfBathroomsTotal": prop.bathrooms
    };
    if (googlePlacesData && googlePlacesData.featured_places?.length > 0) {
      seoData.structured_data.nearbyPoints = googlePlacesData.featured_places.slice(0, 5).map((place)=>({
          "@type": "Place",
          "name": place.place_name,
          "description": place.place_category,
          "address": place.address
        }));
    }
  } else if (type === 'property-list') {
    const properties = searchResults?.properties || [];
    const count = searchResults?.pagination?.totalCount || properties.length;
    const location = extractLocationFromTags(tags) || 'Rep√∫blica Dominicana';
    const propertyType = extractPropertyTypeFromTags(tags) || 'Propiedades';
    const operation = extractOperationFromTags(tags) || 'Venta';
    const displayPrices = properties.map((p)=>p.pricing_unified?.display_price?.amount).filter((p)=>p && p > 0).sort((a, b)=>a - b);
    const minPrice = displayPrices.length > 0 ? displayPrices[0] : null;
    const maxPrice = displayPrices.length > 0 ? displayPrices[displayPrices.length - 1] : null;
    let servicesInfo = '';
    if (googlePlacesData && googlePlacesData.stats.total_places > 0) {
      const topCategories = Object.keys(googlePlacesData.places_by_category).sort((a, b)=>googlePlacesData.places_by_category[b].length - googlePlacesData.places_by_category[a].length).slice(0, 3);
      const categoryNames = {
        'banks': 'bancos',
        'hospitals': 'centros m√©dicos',
        'schools': 'colegios',
        'supermarkets': 'supermercados',
        'shopping_malls': 'centros comerciales',
        'restaurants': 'restaurantes'
      };
      const services = topCategories.map((cat)=>categoryNames[cat] || cat).join(', ');
      servicesInfo = ` Zona con excelentes servicios: ${services}.`;
    }
    seoData.title = `${propertyType} en ${operation} en ${location} | ${count} Disponibles | CLIC Inmobiliaria`;
    let priceInfo = '';
    if (minPrice && maxPrice) {
      if (minPrice === maxPrice) {
        priceInfo = `Precio: $${minPrice.toLocaleString()}`;
      } else {
        priceInfo = `Precios desde $${minPrice.toLocaleString()} hasta $${maxPrice.toLocaleString()}`;
      }
    }
    seoData.description = `Descubre ${count} ${propertyType.toLowerCase()} en ${operation.toLowerCase()} en ${location}. ${priceInfo}.${servicesInfo} ‚úÖ Tours virtuales ‚úÖ Financiamiento disponible`;
    seoData.h1 = `${propertyType} en ${operation} en ${location} - ${count} Propiedades Disponibles`;
    seoData.keywords = [
      `${propertyType.toLowerCase()} ${location.toLowerCase()}`,
      `${operation.toLowerCase()} ${propertyType.toLowerCase()} ${location.toLowerCase()}`,
      `bienes raices ${location.toLowerCase()}`,
      'inmobiliaria republica dominicana',
      'propiedades republica dominicana'
    ];
    seoData.structured_data = {
      "@context": "https://schema.org",
      "@type": "SearchResultsPage",
      "name": seoData.title,
      "description": seoData.description,
      "url": `https://clic.do/${urlSegments?.join('/') || ''}`,
      "mainEntity": {
        "@type": "ItemList",
        "numberOfItems": count,
        "itemListElement": properties.slice(0, 10).map((prop, index)=>({
            "@type": "RealEstateListing",
            "position": index + 1,
            "name": prop.name,
            "url": `https://clic.do/${prop.slug_url}`,
            "offers": {
              "@type": "Offer",
              "price": prop.pricing_unified?.display_price?.amount,
              "priceCurrency": prop.pricing_unified?.display_price?.currency
            }
          }))
      }
    };
    if (googlePlacesData) {
      seoData.places_enrichment = {
        total_services: googlePlacesData.stats.total_places,
        services_score: googlePlacesData.stats.services_score,
        avg_rating: googlePlacesData.stats.avg_rating,
        top_categories: Object.keys(googlePlacesData.places_by_category),
        featured_services: googlePlacesData.featured_places.slice(0, 5)
      };
    }
  }
  seoData.og = {
    title: seoData.title,
    description: seoData.description,
    image: type === 'single-property' || type === 'single-property-project' || type === 'property-not-available' ? property.main_image_optimized?.url : searchResults?.properties?.[0]?.main_image_optimized?.url || 'https://clic.do/default-og-image.jpg',
    url: `https://clic.do/${urlSegments?.join('/') || ''}`,
    type: "website",
    site_name: "CLIC Inmobiliaria",
    locale: "es_DO"
  };
  seoData.twitter = {
    card: "summary_large_image",
    title: seoData.title,
    description: seoData.description,
    image: seoData.og.image,
    site: "@clicinmobiliaria"
  };
  seoData.technical = {
    robots: {
      index: true,
      follow: true,
      "max-snippet": -1,
      "max-image-preview": "large",
      "max-video-preview": -1
    },
    sitemap: {
      lastModified: new Date().toISOString(),
      changeFreq: type === 'single-property' || type === 'single-property-project' || type === 'property-not-available' ? "weekly" : "daily",
      priority: type === 'single-property' || type === 'single-property-project' || type === 'property-not-available' ? 0.8 : 0.6
    }
  };
  return seoData;
}
// =====================================================
// FUNCIONES DE B√öSQUEDA OPTIMIZADAS (EXISTENTES)
// =====================================================
async function searchPropertiesByTags(supabaseClient, tagIds, page = 1, limit = 32) {
  if (tagIds.length === 0) {
    return {
      properties: [],
      totalCount: 0,
      currentPage: page,
      hasMore: false,
      itemsPerPage: limit
    };
  }
  try {
    console.log(`üîç Buscando propiedades con tags: [${tagIds.join(', ')}], p√°gina: ${page}, l√≠mite: ${limit}`);
    let totalCount = 0;
    let validPropertyIds = [];
    const { data: rpcPropertyIds, error: rpcError } = await supabaseClient.rpc('get_properties_with_all_tags', {
      tag_ids: tagIds
    });
    if (!rpcError && rpcPropertyIds && rpcPropertyIds.length > 0) {
      validPropertyIds = rpcPropertyIds;
      totalCount = rpcPropertyIds.length;
      console.log(`‚úÖ RPC exitoso: ${totalCount} propiedades encontradas`);
    } else {
      console.log('üîÑ Usando m√©todo fallback con content_tags');
      const { data: contentTags, error: contentTagsError } = await supabaseClient.from('content_tags').select('content_id, tag_id').eq('content_type', 'properties').in('tag_id', tagIds);
      if (contentTagsError || !contentTags) {
        return {
          properties: [],
          totalCount: 0,
          currentPage: page,
          hasMore: false,
          itemsPerPage: limit
        };
      }
      const tagCountByProperty = {};
      contentTags.forEach((ct)=>{
        tagCountByProperty[ct.content_id] = (tagCountByProperty[ct.content_id] || 0) + 1;
      });
      const requiredTagCount = tagIds.length;
      validPropertyIds = Object.keys(tagCountByProperty).filter((propertyId)=>tagCountByProperty[propertyId] === requiredTagCount);
      totalCount = validPropertyIds.length;
      console.log(`‚úÖ Fallback exitoso: ${totalCount} propiedades encontradas`);
    }
    if (totalCount === 0) {
      return {
        properties: [],
        totalCount: 0,
        currentPage: page,
        hasMore: false,
        itemsPerPage: limit
      };
    }
    const offset = (page - 1) * limit;
    const paginatedPropertyIds = validPropertyIds.slice(offset, offset + limit);
    console.log(`üìÑ Obteniendo p√°gina ${page}: ${paginatedPropertyIds.length} propiedades (offset: ${offset})`);
    // ‚úÖ CONSULTA ACTUALIZADA CON COORDENADAS PARA LISTADOS
    const { data: properties, error: propertiesError } = await supabaseClient.from('properties').select(`
        id, code, name, description, agent_id, slug_url,
        sale_price, sale_currency, rental_price, rental_currency,
        temp_rental_price, temp_rental_currency, 
        furnished_rental_price, furnished_rental_currency,
        bedrooms, bathrooms, parking_spots, built_area, land_area,
        main_image_url, gallery_images_url, property_status, is_project,
        delivery_date, project_detail_id,
        exact_coordinates, show_exact_location,
        property_categories(name, description),
        cities(name, coordinates, provinces(name, coordinates)),
        sectors(name, coordinates),
        property_images(url, title, description, is_main, sort_order)
      `).in('id', paginatedPropertyIds).eq('availability', 1).eq('property_status', 'Publicada');
    if (propertiesError) {
      console.error('‚ùå Error obteniendo propiedades:', propertiesError);
      return {
        properties: [],
        totalCount: 0,
        currentPage: page,
        hasMore: false,
        itemsPerPage: limit
      };
    }
    const hasMore = offset + limit < totalCount;
    console.log(`‚úÖ B√∫squeda completada: ${properties?.length || 0} propiedades obtenidas, ${totalCount} total, hasMore: ${hasMore}`);
    return {
      properties: properties || [],
      totalCount,
      currentPage: page,
      hasMore,
      itemsPerPage: limit
    };
  } catch (error) {
    console.error('‚ùå Error en searchPropertiesByTags:', error);
    return {
      properties: [],
      totalCount: 0,
      currentPage: page,
      hasMore: false,
      itemsPerPage: limit
    };
  }
}
// ‚úÖ FUNCI√ìN ACTUALIZADA: searchPropertyBySlugUrl CON COORDENADAS
async function searchPropertyBySlugUrl(supabaseClient, searchPath) {
  console.log('üîç B√∫squeda por slug_url:', searchPath);
  // ‚úÖ CONSULTA ACTUALIZADA CON COORDENADAS
  const selectQuery = `
    id, code, name, description, agent_id, slug_url,
    sale_price, sale_currency, rental_price, rental_currency,
    temp_rental_price, temp_rental_currency, 
    furnished_rental_price, furnished_rental_currency,
    bedrooms, bathrooms, parking_spots, built_area, land_area,
    main_image_url, gallery_images_url, property_status, is_project,
    delivery_date, project_detail_id,
    exact_coordinates, show_exact_location,
    property_categories(name, description),
    cities(name, coordinates, provinces(name, coordinates)),
    sectors(name, coordinates),
    property_images(url, title, description, is_main, sort_order),
    property_amenities(amenity_id, value, amenities(name, icon, category))
  `;
  const searchVariants = [
    searchPath,
    `/${searchPath}`,
    searchPath.replace(/^\//, ''),
    `/${searchPath.replace(/^\//, '')}`
  ];
  // ‚úÖ MEJORA: Buscar primero en propiedades publicadas
  for (const variant of searchVariants){
    const { data: property, error } = await supabaseClient.from('properties').select(selectQuery).eq('slug_url', variant).eq('availability', 1).eq('property_status', 'Publicada').single();
    if (!error && property) {
      console.log(`‚úÖ Propiedad DISPONIBLE encontrada con slug: "${variant}"`);
      // ‚úÖ PROCESAR Y LOGGEAR COORDENADAS
      const coordinatesInfo = processPropertyCoordinates(property);
      console.log('üìç Coordenadas procesadas:', coordinatesInfo);
      return {
        found: true,
        property: property,
        searchMethod: 'exact_slug',
        matchedVariant: variant,
        available: true,
        coordinatesInfo
      };
    }
  }
  // ‚úÖ NUEVA FUNCIONALIDAD: Buscar en propiedades NO disponibles (vendidas/retiradas)
  console.log('üîç Propiedad no encontrada en disponibles, buscando en no disponibles...');
  for (const variant of searchVariants){
    const { data: property, error } = await supabaseClient.from('properties').select(selectQuery).eq('slug_url', variant).single(); // Sin filtros de disponibilidad
    if (!error && property && property.property_status !== 'Publicada') {
      console.log(`‚ö†Ô∏è Propiedad NO DISPONIBLE encontrada con slug: "${variant}", status: ${property.property_status}`);
      // ‚úÖ PROCESAR COORDENADAS TAMBI√âN PARA PROPIEDADES NO DISPONIBLES
      const coordinatesInfo = processPropertyCoordinates(property);
      console.log('üìç Coordenadas procesadas (no disponible):', coordinatesInfo);
      return {
        found: true,
        property: property,
        searchMethod: 'exact_slug_sold',
        matchedVariant: variant,
        available: false,
        soldStatus: property.property_status,
        coordinatesInfo
      };
    }
  }
  return {
    found: false,
    property: null,
    searchPath: searchPath,
    available: false
  };
}
// =====================================================
// ‚ú® FUNCIONES DE PROPIEDADES SIMILARES (EXISTENTES)
// =====================================================
async function getPropertyTags(supabaseClient, propertyId) {
  try {
    console.log('üè∑Ô∏è Obteniendo tags de la propiedad:', propertyId);
    const { data: contentTags, error } = await supabaseClient.from('content_tags').select(`
        tag_id,
        weight,
        tags!inner(id, name, slug, category, display_name)
      `).eq('content_id', propertyId).eq('content_type', 'property').order('weight', {
      ascending: false
    });
    if (error) {
      console.error('‚ùå Error obteniendo tags de propiedad:', error);
      return [];
    }
    const tags = (contentTags || []).filter((ct)=>ct.tags).map((ct)=>({
        ...ct.tags,
        weight: ct.weight || 1
      }));
    console.log('‚úÖ Tags de propiedad obtenidos:', {
      total: tags.length,
      byCategory: tags.reduce((acc, tag)=>{
        acc[tag.category] = (acc[tag.category] || 0) + 1;
        return acc;
      }, {}),
      topWeights: tags.slice(0, 5).map((t)=>`${t.category}:${t.name}(${t.weight})`)
    });
    return tags;
  } catch (error) {
    console.error('‚ùå Error en getPropertyTags:', error);
    return [];
  }
}
async function getSmartSimilarProperties(supabaseClient, propertyTags, excludeId) {
  console.log('üè† === BUSCANDO PROPIEDADES SIMILARES INTELIGENTES ===');
  console.log('üìã Exclude ID:', excludeId);
  console.log('üìã Tags disponibles:', propertyTags?.length || 0);
  if (!propertyTags || propertyTags.length === 0) {
    console.log('‚ö†Ô∏è No hay tags de la propiedad, buscando propiedades aleatorias');
    return await getFallbackSimilarProperties(supabaseClient, excludeId);
  }
  try {
    const tagIds = propertyTags.map((t)=>t.id);
    console.log('üîç Buscando propiedades que tengan estos tag IDs:', tagIds);
    const { data: propertyMatches, error } = await supabaseClient.from('content_tags').select(`
        content_id,
        tag_id,
        weight,
        tags(id, name, category)
      `).eq('content_type', 'property').in('tag_id', tagIds).neq('content_id', excludeId);
    if (error || !propertyMatches) {
      console.error('‚ùå Error buscando propiedades similares:', error);
      return await getFallbackSimilarProperties(supabaseClient, excludeId);
    }
    console.log('üìä Property matches encontrados:', propertyMatches.length);
    const propertyScores = {};
    const categoryWeights = {
      'operacion': 5,
      'categoria': 4,
      'ciudad': 3,
      'sector': 3,
      'provincia': 2,
      'caracteristica': 1
    };
    propertyMatches.forEach((match)=>{
      const propertyId = match.content_id;
      const tagCategory = match.tags?.category || 'caracteristica';
      const categoryWeight = categoryWeights[tagCategory] || 1;
      const tagWeight = match.weight || 1;
      if (!propertyScores[propertyId]) {
        propertyScores[propertyId] = {
          property_id: propertyId,
          total_score: 0,
          matched_tags: 0,
          categories: new Set()
        };
      }
      propertyScores[propertyId].total_score += categoryWeight * tagWeight;
      propertyScores[propertyId].matched_tags += 1;
      propertyScores[propertyId].categories.add(tagCategory);
    });
    const validProperties = Object.values(propertyScores).filter((prop)=>prop.matched_tags >= 2).sort((a, b)=>b.total_score - a.total_score).slice(0, 6);
    if (validProperties.length === 0) {
      console.log('‚ö†Ô∏è No hay propiedades con suficientes coincidencias, bajando a 1 tag m√≠nimo');
      const validPropertiesLowBar = Object.values(propertyScores).filter((prop)=>prop.matched_tags >= 1).sort((a, b)=>b.total_score - a.total_score).slice(0, 6);
      if (validPropertiesLowBar.length === 0) {
        return await getFallbackSimilarProperties(supabaseClient, excludeId);
      }
      const propertyIds = validPropertiesLowBar.map((p)=>p.property_id);
      return await getPropertiesDetails(supabaseClient, propertyIds);
    }
    console.log('üìä Propiedades similares encontradas:', {
      totalMatches: Object.keys(propertyScores).length,
      with2PlusMatches: validProperties.length,
      topScores: validProperties.slice(0, 3).map((p)=>`${p.matched_tags} tags, score: ${p.total_score}`)
    });
    const propertyIds = validProperties.map((p)=>p.property_id);
    return await getPropertiesDetails(supabaseClient, propertyIds);
  } catch (error) {
    console.error('‚ùå Error en getSmartSimilarProperties:', error);
    return await getFallbackSimilarProperties(supabaseClient, excludeId);
  }
}
async function getFallbackSimilarProperties(supabaseClient, excludeId) {
  console.log('üîÑ Usando m√©todo fallback para propiedades similares');
  try {
    const { data: properties, error } = await supabaseClient.from('properties').select(`
        id, code, name, sale_price, rental_price, temp_rental_price,
        furnished_rental_price, sale_currency, rental_currency,
        bedrooms, bathrooms, parking_spots, built_area, land_area,
        main_image_url, gallery_images_url, is_project, slug_url,
        property_categories(name),
        cities(name, provinces(name)),
        sectors(name),
        property_images(url, title, description, is_main, sort_order)
      `).neq('id', excludeId).eq('availability', 1).eq('property_status', 'Publicada').order('created_at', {
      ascending: false
    }).limit(6);
    if (error) {
      console.error('‚ùå Error en fallback properties:', error);
      return [];
    }
    console.log('‚úÖ Propiedades fallback obtenidas:', properties?.length || 0);
    return (properties || []).map(formatSimilarProperty);
  } catch (error) {
    console.error('‚ùå Error en getFallbackSimilarProperties:', error);
    return [];
  }
}
async function getPropertiesDetails(supabaseClient, propertyIds) {
  if (!propertyIds || propertyIds.length === 0) return [];
  console.log('üìã Obteniendo detalles de', propertyIds.length, 'propiedades similares');
  try {
    const { data: properties, error } = await supabaseClient.from('properties').select(`
        id, code, name, sale_price, rental_price, temp_rental_price,
        furnished_rental_price, sale_currency, rental_currency,
        bedrooms, bathrooms, parking_spots, built_area, land_area,
        main_image_url, gallery_images_url, is_project, slug_url,
        property_categories(name),
        cities(name, provinces(name)),
        sectors(name),
        property_images(url, title, description, is_main, sort_order)
      `).in('id', propertyIds).eq('availability', 1).eq('property_status', 'Publicada');
    if (error) {
      console.error('‚ùå Error obteniendo detalles de propiedades:', error);
      return [];
    }
    const orderedProperties = propertyIds.map((id)=>properties?.find((prop)=>prop.id === id)).filter(Boolean);
    console.log('‚úÖ Propiedades similares obtenidas:', orderedProperties.length);
    return orderedProperties.map(formatSimilarProperty);
  } catch (error) {
    console.error('‚ùå Error en getPropertiesDetails:', error);
    return [];
  }
}
function formatSimilarProperty(property) {
  let price = 'Precio a consultar';
  if (property.sale_price) {
    price = `$${property.sale_price.toLocaleString()} ${property.sale_currency || 'USD'}`;
  } else if (property.rental_price) {
    price = `$${property.rental_price.toLocaleString()} ${property.rental_currency || 'USD'}/mes`;
  } else if (property.temp_rental_price) {
    price = `$${property.temp_rental_price.toLocaleString()} ${property.temp_rental_currency || 'USD'}/noche`;
  } else if (property.furnished_rental_price) {
    price = `$${property.furnished_rental_price.toLocaleString()} ${property.furnished_rental_currency || 'USD'}/mes`;
  }
  let mainImage = property.main_image_url;
  if (!mainImage && property.property_images && property.property_images.length > 0) {
    const mainImg = property.property_images.find((img)=>img.is_main);
    mainImage = mainImg ? mainImg.url : property.property_images[0].url;
  }
  if (!mainImage && property.gallery_images_url) {
    if (Array.isArray(property.gallery_images_url)) {
      mainImage = property.gallery_images_url[0];
    } else if (typeof property.gallery_images_url === 'string') {
      mainImage = property.gallery_images_url.split(',')[0]?.trim();
    }
  }
  const locationParts = [
    property.sectors?.name,
    property.cities?.name
  ].filter(Boolean);
  const location = locationParts.length > 0 ? locationParts.join(', ') : 'Ubicaci√≥n no especificada';
  return {
    id: property.id,
    title: property.name,
    price: price,
    bedrooms: property.bedrooms,
    bathrooms: property.bathrooms,
    area: property.built_area || property.land_area,
    image: mainImage || '/images/placeholder-property.jpg',
    location: location,
    type: property.property_categories?.name,
    url: property.slug_url || `/propiedad/${property.id}`,
    is_project: property.is_project,
    parking_spots: property.parking_spots
  };
}
// =====================================================
// ‚ú® NUEVA FUNCI√ìN: PROPIEDADES DEL ASESOR
// =====================================================
async function getAgentProperties(supabaseClient, agentId, excludePropertyId = null, limit = 20) {
  if (!agentId) {
    console.log('‚ö†Ô∏è No se proporcion√≥ agent_id');
    return [];
  }
  console.log('üë§ === OBTENIENDO PROPIEDADES DEL ASESOR ===');
  console.log('üìã Agent ID:', agentId);
  console.log('üìã Exclude Property ID:', excludePropertyId);
  console.log('üìã L√≠mite:', limit);
  try {
    let query = supabaseClient.from('properties').select(`
        id, code, name, sale_price, rental_price, temp_rental_price,
        furnished_rental_price, sale_currency, rental_currency,
        bedrooms, bathrooms, parking_spots, built_area, land_area,
        main_image_url, gallery_images_url, is_project, slug_url,
        property_categories(name),
        cities(name, provinces(name)),
        sectors(name),
        property_images(url, title, description, is_main, sort_order)
      `).eq('agent_id', agentId).eq('availability', 1).eq('property_status', 'Publicada').order('created_at', {
      ascending: false
    }).limit(limit);
    // Excluir la propiedad actual si se proporciona
    if (excludePropertyId) {
      query = query.neq('id', excludePropertyId);
    }
    const { data: properties, error } = await query;
    if (error) {
      console.error('‚ùå Error obteniendo propiedades del asesor:', error);
      return [];
    }
    if (!properties || properties.length === 0) {
      console.log('‚ö†Ô∏è No se encontraron propiedades para este asesor');
      return [];
    }
    console.log('‚úÖ Propiedades del asesor obtenidas:', {
      total: properties.length,
      agentId: agentId,
      excluded: excludePropertyId
    });
    return properties.map(formatSimilarProperty);
  } catch (error) {
    console.error('‚ùå Error en getAgentProperties:', error);
    return [];
  }
}
// =====================================================
// ‚ú® FUNCI√ìN DE CONTENIDO RELACIONADO POR TAGS CON ART√çCULOS CORREGIDOS
// =====================================================
async function getRelatedContent(supabaseClient, tagIds, limitPerType = 5) {
  if (!tagIds || tagIds.length === 0) {
    console.log('‚ö†Ô∏è No hay tags para buscar contenido relacionado');
    return {
      articles: [],
      videos: [],
      testimonials: [],
      faqs: [],
      seo_content: []
    };
  }
  console.log('üîç === OBTENIENDO CONTENIDO RELACIONADO POR TAGS ===');
  console.log('üìã Par√°metros:', {
    tagIds,
    limitPerType,
    tagCount: tagIds.length
  });
  try {
    console.log('üöÄ Llamando RPC get_all_content_by_tags...');
    const { data: contentResults, error: rpcError } = await supabaseClient.rpc('get_all_content_by_tags', {
      tag_ids: tagIds,
      limit_per_type: limitPerType
    });
    if (rpcError) {
      console.error('‚ùå Error en RPC get_all_content_by_tags:', rpcError);
      return {
        articles: [],
        videos: [],
        testimonials: [],
        faqs: [],
        seo_content: []
      };
    }
    if (!contentResults || contentResults.length === 0) {
      console.log('‚ö†Ô∏è No se encontr√≥ contenido relacionado por tags');
      return {
        articles: [],
        videos: [],
        testimonials: [],
        faqs: [],
        seo_content: []
      };
    }
    console.log('‚úÖ RPC ejecutado exitosamente:', {
      totalResults: contentResults.length,
      types: [
        ...new Set(contentResults.map((r)=>r.content_type))
      ]
    });
    const groupedIds = {
      article: [],
      video: [],
      testimonial: [],
      faq: [],
      seo_content: []
    };
    const metadataMap = {};
    contentResults.forEach((result)=>{
      const { content_id, content_type, total_weight, matched_tags } = result;
      if (groupedIds[content_type]) {
        groupedIds[content_type].push(content_id);
        metadataMap[content_id] = {
          total_weight,
          matched_tags,
          content_type,
          is_tag_related: true
        };
      }
    });
    console.log('üìä Contenido agrupado por tags:', {
      articles: groupedIds.article.length,
      videos: groupedIds.video.length,
      testimonials: groupedIds.testimonial.length,
      faqs: groupedIds.faq.length,
      seo_content: groupedIds.seo_content.length
    });
    const contentResults_final = {
      articles: [],
      videos: [],
      testimonials: [],
      faqs: [],
      seo_content: []
    };
    // ‚úÖ CONSULTA CORREGIDA PARA ART√çCULOS CON TODOS LOS CAMPOS
    if (groupedIds.article.length > 0) {
      console.log('üìö Obteniendo', groupedIds.article.length, 'art√≠culos por tags...');
      const { data: articles, error: articlesError } = await supabaseClient.from('articles').select(`
          id, title, slug, excerpt, content, featured_image,
          published_at, created_at, updated_at,
          meta_title, meta_description, read_time,
          views, featured, category, author_id,
          users!articles_author_id_fkey(
            first_name, last_name, profile_photo_url
          )
        `).in('id', groupedIds.article).eq('status', 'published').order('published_at', {
        ascending: false
      });
      if (!articlesError && articles) {
        contentResults_final.articles = articles.map((article)=>{
          // Formatear autor
          const author = {
            name: article.users ? `${article.users.first_name || ''} ${article.users.last_name || ''}`.trim() || 'Equipo CLIC' : 'Equipo CLIC',
            avatar: article.users?.profile_photo_url || '/images/team/clic-experts.jpg'
          };
          return {
            ...article,
            ...metadataMap[article.id],
            // ‚úÖ MAPEAR CAMPOS CORRECTAMENTE PARA RelatedArticles
            featuredImage: article.featured_image,
            publishedAt: article.published_at,
            readTime: article.read_time ? `${article.read_time} min` : '8 min',
            author: author,
            // ‚úÖ CAMPOS YA DISPONIBLES EN LA TABLA
            category: article.category || 'Art√≠culos',
            views: article.views || `${Math.floor(Math.random() * 5 + 1)}.${Math.floor(Math.random() * 9 + 1)}K`,
            featured: article.featured || false
          };
        });
      }
    }
    if (groupedIds.video.length > 0) {
      console.log('üé• Obteniendo', groupedIds.video.length, 'videos por tags...');
      const { data: videos, error: videosError } = await supabaseClient.from('videos').select(`
          id, title, description, video_slug, thumbnail, video_id, 
          video_platform, duration, views, category, featured,
          meta_title, meta_description, status, published_at, 
          created_at, updated_at, subtitle
        `).in('id', groupedIds.video).eq('status', 'published').order('published_at', {
        ascending: false
      });
      if (!videosError && videos) {
        contentResults_final.videos = videos.map((video)=>({
            ...video,
            ...metadataMap[video.id],
            formatted_duration: formatDuration(video.duration),
            youtube_url: video.video_platform === 'youtube' && video.video_id ? `https://www.youtube.com/watch?v=${video.video_id}` : null
          }));
      }
    }
    if (groupedIds.testimonial.length > 0) {
      console.log('üí¨ Obteniendo', groupedIds.testimonial.length, 'testimonios por tags...');
      const { data: testimonials, error: testimonialsError } = await supabaseClient.from('testimonials').select(`
          id, slug, title, excerpt, full_testimonial, rating,
          client_name, client_avatar, client_location, client_verified,
          client_profession, featured_image, views, featured,
          meta_title, meta_description, status, published_at, created_at
        `).in('id', groupedIds.testimonial).eq('status', 'published').order('published_at', {
        ascending: false
      });
      if (!testimonialsError && testimonials) {
        contentResults_final.testimonials = testimonials.map((testimonial)=>({
            ...testimonial,
            ...metadataMap[testimonial.id],
            content: testimonial.full_testimonial,
            client_title: testimonial.client_profession
          }));
      }
    }
    if (groupedIds.faq.length > 0) {
      console.log('‚ùì Obteniendo', groupedIds.faq.length, 'FAQs por tags...');
      const { data: faqs, error: faqsError } = await supabaseClient.from('faqs').select(`
          id, question, answer, sort_order,
          created_at, updated_at
        `).in('id', groupedIds.faq).eq('status', 'published').order('sort_order', {
        ascending: true
      });
      if (!faqsError && faqs) {
        contentResults_final.faqs = faqs.map((faq)=>({
            ...faq,
            ...metadataMap[faq.id]
          }));
      }
    }
    if (groupedIds.seo_content.length > 0) {
      console.log('üéØ Obteniendo', groupedIds.seo_content.length, 'contenido SEO por tags...');
      const { data: seoContent, error: seoError } = await supabaseClient.from('seo_content').select(`
          id, title, description, h1_title, h2_subtitle, 
          seo_content, content_type, identifier,
          location_context, property_type_context, operation_context,
          views, performance_score, version, status,
          created_at, updated_at
        `).in('id', groupedIds.seo_content).eq('status', 'published').order('created_at', {
        ascending: false
      });
      if (!seoError && seoContent) {
        contentResults_final.seo_content = seoContent.map((content)=>({
            ...content,
            ...metadataMap[content.id],
            content: content.seo_content,
            page_url: content.identifier
          }));
      }
    }
    console.log('‚úÖ Contenido relacionado por tags obtenido:', {
      articles: contentResults_final.articles.length,
      videos: contentResults_final.videos.length,
      testimonials: contentResults_final.testimonials.length,
      faqs: contentResults_final.faqs.length,
      seo_content: contentResults_final.seo_content.length
    });
    return contentResults_final;
  } catch (error) {
    console.error('‚ùå Error obteniendo contenido relacionado por tags:', error);
    return {
      articles: [],
      videos: [],
      testimonials: [],
      faqs: [],
      seo_content: []
    };
  }
}
function formatDuration(seconds) {
  if (!seconds) return null;
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor(seconds % 3600 / 60);
  const remainingSeconds = seconds % 60;
  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  } else {
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  }
}
// =====================================================
// ‚ú® NUEVA FUNCI√ìN: OBTENER ESTAD√çSTICAS DE ART√çCULOS
// =====================================================
async function getArticlesStats(supabaseClient) {
  try {
    const { count, error } = await supabaseClient.from('articles').select('*', {
      count: 'exact',
      head: true
    }).eq('status', 'published');
    if (error) {
      console.error('‚ùå Error obteniendo stats de art√≠culos:', error);
      return {
        total_articles: 200,
        last_updated: 'Contenido actualizado semanalmente'
      };
    }
    return {
      total_articles: count || 200,
      last_updated: 'Contenido actualizado semanalmente'
    };
  } catch (error) {
    console.error('‚ùå Error cr√≠tico en getArticlesStats:', error);
    return {
      total_articles: 200,
      last_updated: 'Contenido actualizado semanalmente'
    };
  }
}
// =====================================================
// ‚ú® FUNCIONES DE ASESOR MEJORADAS
// =====================================================
const agentCache = new Map();
async function getPropertyAgent(supabaseClient, agentId) {
  if (!agentId) return null;
  if (agentCache.has(agentId)) {
    return agentCache.get(agentId);
  }
  try {
    // ‚úÖ MEJORA: Agregar campos adicionales solicitados
    const { data: agent, error } = await supabaseClient.from('users').select(`
        id, external_id, first_name, last_name, email, phone, 
        position, slug, biography, facebook_url, instagram_url, 
        twitter_url, linkedin_url, youtube_url,
        active, show_on_website, user_type, team_id,
        profile_photo_url, years_experience, specialty_description, languages
      `).eq('id', agentId).single();
    if (error) {
      console.log('‚ùå Error obteniendo agente:', error.message);
      return null;
    }
    agentCache.set(agentId, agent);
    setTimeout(()=>agentCache.delete(agentId), 15 * 60 * 1000);
    return agent;
  } catch (error) {
    console.error('‚ùå Error cr√≠tico buscando agente:', error);
    return null;
  }
}
async function getReferralAgent(supabaseClient, externalId) {
  if (!externalId) return null;
  try {
    // ‚úÖ MEJORA: Agregar campos adicionales para referidos tambi√©n
    const { data: referralAgent, error } = await supabaseClient.from('users').select(`
        id, external_id, first_name, last_name, email, phone, 
        position, slug, biography, facebook_url, instagram_url, 
        twitter_url, linkedin_url, youtube_url,
        active, show_on_website, user_type, team_id,
        profile_photo_url, years_experience, specialty_description, languages
      `).eq('external_id', externalId).eq('active', true).single();
    if (error || !referralAgent) {
      console.log('‚ö†Ô∏è Usuario referido no encontrado:', externalId);
      return null;
    }
    return referralAgent;
  } catch (error) {
    console.error('‚ùå Error buscando usuario referido:', error);
    return null;
  }
}
function formatAgent(agent, type = 'agent') {
  if (!agent) return null;
  // ‚úÖ MEJORA: Formatear campos adicionales
  return {
    id: agent.id,
    name: `${agent.first_name || ''} ${agent.last_name || ''}`.trim(),
    email: agent.email,
    phone: agent.phone,
    position: agent.position || 'Asesor Inmobiliario',
    slug: agent.slug,
    biography: agent.biography,
    external_id: agent.external_id,
    // ‚úÖ NUEVOS CAMPOS AGREGADOS
    profile_photo_url: agent.profile_photo_url,
    years_experience: agent.years_experience || 0,
    specialty_description: agent.specialty_description,
    languages: agent.languages,
    social: {
      facebook: agent.facebook_url,
      instagram: agent.instagram_url,
      twitter: agent.twitter_url,
      linkedin: agent.linkedin_url,
      youtube: agent.youtube_url
    },
    active: agent.active,
    show_on_website: agent.show_on_website,
    team_id: agent.team_id,
    user_type: agent.user_type,
    agent_type: type
  };
}
// =====================================================
// FUNCIONES DE CONTENIDO Y PROYECTO (EXISTENTES)
// =====================================================
async function getCompleteProjectDetails(supabaseClient, projectDetailId) {
  if (!projectDetailId) return null;
  try {
    const { data: projectData, error } = await supabaseClient.from('project_details').select(`
        *,
        developers(*),
        project_typologies(*),
        project_amenities(*, amenities(*)),
        project_payment_plans(*),
        project_phases(*),
        project_availability(*, project_typologies(*)),
        project_benefits(*, project_benefits_catalog(*)),
        project_documents(*, project_documents_catalog(*))
      `).eq('id', projectDetailId).single();
    if (error) {
      console.error('‚ùå Error obteniendo detalles del proyecto:', error);
      return null;
    }
    return projectData;
  } catch (error) {
    console.error('‚ùå Error cr√≠tico en getCompleteProjectDetails:', error);
    return null;
  }
}
async function getPropertySpecificContent(supabaseClient, propertyId) {
  try {
    // Debug b√°sico
    console.log('üîç getPropertySpecificContent - propertyId:', propertyId);
    const { data: relations, error } = await supabaseClient.from('content_property_relations').select('content_id, content_type, relation_type, weight').eq('property_id', propertyId).order('weight', {
      ascending: false
    });
    // Debug de la consulta principal
    console.log('üîç Relations found:', relations?.length || 0);
    console.log('üîç Relations error:', error);
    if (error || !relations || relations.length === 0) {
      console.log('‚ö†Ô∏è No relations found or error occurred');
      return null;
    }
    const contentByType = relations.reduce((acc, rel)=>{
      if (!acc[rel.content_type]) acc[rel.content_type] = [];
      acc[rel.content_type].push(rel.content_id);
      return acc;
    }, {});
    // Debug del agrupamiento
    console.log('üîç Content by type:', contentByType);
    console.log('üîç Content by type keys:', Object.keys(contentByType));
    // ‚úÖ CORRECCI√ìN PRINCIPAL: Usar las claves correctas del content_type
    const [articles, videos, testimonials, faqs] = await Promise.all([
      // ‚úÖ CORREGIDO: usar 'article' en lugar de 'articles' + CAMPOS COMPLETOS
      contentByType.article ? supabaseClient.from('articles').select(`
        id, title, slug, excerpt, content, featured_image,
        published_at, created_at, updated_at,
        meta_title, meta_description, read_time,
        views, featured, category, author_id,
        users!articles_author_id_fkey(
          first_name, last_name, profile_photo_url
        )
      `).in('id', contentByType.article).eq('status', 'published') : Promise.resolve({
        data: []
      }),
      // ‚úÖ CORREGIDO: usar 'video' en lugar de 'videos'  
      contentByType.video ? supabaseClient.from('videos').select('*').in('id', contentByType.video).eq('status', 'published') : Promise.resolve({
        data: []
      }),
      // ‚úÖ CORREGIDO: usar 'testimonial' en lugar de 'testimonials'
      contentByType.testimonial ? supabaseClient.from('testimonials').select('*').in('id', contentByType.testimonial).eq('status', 'published') : Promise.resolve({
        data: []
      }),
      // ‚úÖ CORREGIDO: usar 'faq' en lugar de 'faqs'
      contentByType.faq ? supabaseClient.from('faqs').select('*').in('id', contentByType.faq).eq('status', 'published') : Promise.resolve({
        data: []
      })
    ]);
    // Debug detallado despu√©s de las consultas
    console.log('üîç === DEBUGGING CONSULTAS INDIVIDUALES CORREGIDAS ===');
    console.log('üîç contentByType.article IDs:', contentByType.article);
    console.log('üîç contentByType.video IDs:', contentByType.video);
    console.log('üîç contentByType.testimonial IDs:', contentByType.testimonial);
    console.log('üîç contentByType.faq IDs:', contentByType.faq);
    console.log('üîç Articles query result:', {
      dataLength: articles.data?.length || 0,
      error: articles.error,
      hasData: !!articles.data
    });
    console.log('üîç Videos query result:', {
      dataLength: videos.data?.length || 0,
      error: videos.error,
      hasData: !!videos.data
    });
    console.log('üîç Testimonials query result:', {
      dataLength: testimonials.data?.length || 0,
      error: testimonials.error,
      hasData: !!testimonials.data
    });
    console.log('üîç FAQs query result:', {
      dataLength: faqs.data?.length || 0,
      error: faqs.error,
      hasData: !!faqs.data
    });
    // ‚úÖ PROCESAR ART√çCULOS ESPEC√çFICOS CON MAPEO CORRECTO
    const processedArticles = articles.data ? articles.data.map((article)=>{
      // Formatear autor
      const author = {
        name: article.users ? `${article.users.first_name || ''} ${article.users.last_name || ''}`.trim() || 'Equipo CLIC' : 'Equipo CLIC',
        avatar: article.users?.profile_photo_url || '/images/team/clic-experts.jpg'
      };
      return {
        ...article,
        // ‚úÖ MAPEAR CAMPOS CORRECTAMENTE PARA RelatedArticles
        featuredImage: article.featured_image,
        publishedAt: article.published_at,
        readTime: article.read_time ? `${article.read_time} min` : '8 min',
        author: author,
        // ‚úÖ CAMPOS YA DISPONIBLES EN LA TABLA
        category: article.category || 'Art√≠culos',
        views: article.views || `${Math.floor(Math.random() * 5 + 1)}.${Math.floor(Math.random() * 9 + 1)}K`,
        featured: article.featured || false
      };
    }) : [];
    // Debug del resultado final
    const result = {
      articles: processedArticles,
      videos: videos.data || [],
      testimonials: testimonials.data || [],
      faqs: faqs.data || [],
      has_specific_content: true
    };
    console.log('‚úÖ Specific content final CORREGIDO:', {
      articles: result.articles.length,
      videos: result.videos.length,
      testimonials: result.testimonials.length,
      faqs: result.faqs.length,
      total: result.articles.length + result.videos.length + result.testimonials.length + result.faqs.length,
      hasAnyContent: result.articles.length + result.videos.length + result.testimonials.length + result.faqs.length > 0
    });
    return result;
  } catch (error) {
    console.error('‚ùå Error obteniendo contenido espec√≠fico:', error);
    return null;
  }
}
// ‚úÖ FUNCI√ìN ACTUALIZADA: getDefaultRelatedContent CON ART√çCULOS COMPLETOS
async function getDefaultRelatedContent(supabaseClient) {
  try {
    const [articles, videos, faqs, testimonials] = await Promise.all([
      supabaseClient.from('articles').select(`
        id, title, slug, excerpt, content, featured_image,
        published_at, created_at, updated_at,
        meta_title, meta_description, read_time,
        views, featured, category, author_id,
        users!articles_author_id_fkey(
          first_name, last_name, profile_photo_url
        )
      `).eq('status', 'published').order('published_at', {
        ascending: false
      }).limit(5),
      supabaseClient.from('videos').select('*').eq('status', 'published').order('published_at', {
        ascending: false
      }).limit(4),
      supabaseClient.from('faqs').select('*').eq('status', 'published').order('sort_order').limit(6),
      supabaseClient.from('testimonials').select('*').eq('status', 'published').order('published_at', {
        ascending: false
      }).limit(3)
    ]);
    // ‚úÖ PROCESAR ART√çCULOS POR DEFECTO CON MAPEO CORRECTO
    const processedArticles = articles.data ? articles.data.map((article)=>{
      // Formatear autor
      const author = {
        name: article.users ? `${article.users.first_name || ''} ${article.users.last_name || ''}`.trim() || 'Equipo CLIC' : 'Equipo CLIC',
        avatar: article.users?.profile_photo_url || '/images/team/clic-experts.jpg'
      };
      return {
        ...article,
        // ‚úÖ MAPEAR CAMPOS CORRECTAMENTE PARA RelatedArticles
        featuredImage: article.featured_image,
        publishedAt: article.published_at,
        readTime: article.read_time ? `${article.read_time} min` : '8 min',
        author: author,
        // ‚úÖ CAMPOS YA DISPONIBLES EN LA TABLA
        category: article.category || 'Art√≠culos',
        views: article.views || `${Math.floor(Math.random() * 5 + 1)}.${Math.floor(Math.random() * 9 + 1)}K`,
        featured: article.featured || false
      };
    }) : [];
    return {
      articles: processedArticles,
      videos: videos.data || [],
      testimonials: testimonials.data || [],
      faqs: faqs.data || []
    };
  } catch (error) {
    console.error('‚ùå Error obteniendo contenido por defecto:', error);
    return {
      articles: [],
      videos: [],
      testimonials: [],
      faqs: []
    };
  }
}
// =====================================================
// ‚úÖ FUNCI√ìN COMPLETAMENTE CORREGIDA: combineContentWithTagsHierarchy
// PRIORIDAD ABSOLUTA PARA CONTENIDO ESPEC√çFICO
// =====================================================
function combineContentWithTagsHierarchy(specificContent, tagRelatedContent, defaultContent) {
  console.log('üîÑ === COMBINANDO CONTENIDO CON PRIORIDAD ABSOLUTA PARA ESPEC√çFICOS (CORREGIDA) ===');
  // Debug detallado de entrada
  console.log('üìä Contenido recibido:', {
    specific: {
      hasContent: !!specificContent?.has_specific_content,
      articles: specificContent?.articles?.length || 0,
      videos: specificContent?.videos?.length || 0,
      testimonials: specificContent?.testimonials?.length || 0,
      faqs: specificContent?.faqs?.length || 0,
      seo_content: specificContent?.seo_content?.length || 0
    },
    tagRelated: {
      articles: tagRelatedContent?.articles?.length || 0,
      videos: tagRelatedContent?.videos?.length || 0,
      testimonials: tagRelatedContent?.testimonials?.length || 0,
      faqs: tagRelatedContent?.faqs?.length || 0,
      seo_content: tagRelatedContent?.seo_content?.length || 0
    },
    default: {
      articles: defaultContent?.articles?.length || 0,
      videos: defaultContent?.videos?.length || 0,
      testimonials: defaultContent?.testimonials?.length || 0,
      faqs: defaultContent?.faqs?.length || 0,
      seo_content: defaultContent?.seo_content?.length || 0
    }
  });
  const maxLimits = {
    articles: 12,
    videos: 10,
    testimonials: 8,
    faqs: 15,
    seo_content: 8
  };
  const combined = {
    articles: [],
    videos: [],
    testimonials: [],
    faqs: [],
    seo_content: [],
    content_source: 'hierarchical',
    hierarchy_info: {
      specific_count: 0,
      tag_related_count: 0,
      default_count: 0
    }
  };
  // ‚úÖ FUNCI√ìN CORREGIDA: Combinar tipo de contenido con orden y limpieza correctos
  function combineContentType(type) {
    const maxLimit = maxLimits[type];
    let currentCount = 0;
    let specificCount = 0;
    let tagRelatedCount = 0;
    let defaultCount = 0;
    const usedIds = new Set();
    const finalItems = [];
    console.log(`\nüîÑ === PROCESANDO ${type.toUpperCase()} ===`);
    // üéØ PRIORIDAD 1: CONTENIDO ESPEC√çFICO (PRIORIDAD ABSOLUTA - SIN L√çMITES)
    if (specificContent?.has_specific_content && specificContent[type]) {
      console.log(`üéØ Procesando contenido espec√≠fico para ${type}:`, specificContent[type].length);
      specificContent[type].forEach((item, index)=>{
        if (!usedIds.has(item.id)) {
          // ‚úÖ LIMPIAR campos incorrectos del contenido espec√≠fico
          const cleanItem = {
            ...item,
            content_priority: 'specific',
            is_property_specific: true
          };
          // ‚ùå REMOVER campos que NO deben estar en contenido espec√≠fico
          delete cleanItem.total_weight;
          delete cleanItem.matched_tags;
          delete cleanItem.content_type;
          delete cleanItem.is_tag_related;
          delete cleanItem.is_default_content;
          finalItems.push(cleanItem);
          usedIds.add(item.id);
          specificCount++;
          console.log(`  ‚úÖ Espec√≠fico #${index + 1}: ${item.id} - ${item.title || item.question || 'Sin t√≠tulo'}`);
        } else {
          console.log(`  ‚ö†Ô∏è Espec√≠fico duplicado evitado: ${item.id}`);
        }
      });
      currentCount = specificCount;
      console.log(`üéØ ${type}: Agregados ${specificCount} items espec√≠ficos (PRIORIDAD ABSOLUTA - TODOS)`);
    } else {
      console.log(`üéØ ${type}: No hay contenido espec√≠fico disponible`);
    }
    // üéØ PRIORIDAD 2: CONTENIDO POR TAGS (hasta l√≠mite total, sin duplicados)
    if (currentCount < maxLimit && tagRelatedContent?.[type]) {
      const remainingSlots = maxLimit - currentCount;
      console.log(`üè∑Ô∏è Procesando contenido por tags para ${type}: ${tagRelatedContent[type].length} disponibles, ${remainingSlots} slots restantes`);
      const uniqueTagItems = tagRelatedContent[type].filter((item)=>{
        const isUnique = !usedIds.has(item.id);
        if (!isUnique) {
          console.log(`  ‚ö†Ô∏è Tag duplicado evitado: ${item.id}`);
        }
        return isUnique;
      });
      const tagItems = uniqueTagItems.slice(0, remainingSlots).map((item, index)=>{
        const cleanItem = {
          ...item,
          content_priority: 'tag_related',
          is_tag_related: true
        };
        // ‚úÖ LIMPIAR campos inconsistentes si existen
        delete cleanItem.is_property_specific;
        delete cleanItem.is_default_content;
        usedIds.add(item.id);
        console.log(`  ‚úÖ Tag #${index + 1}: ${item.id} - ${item.title || item.question || 'Sin t√≠tulo'}`);
        return cleanItem;
      });
      finalItems.push(...tagItems);
      currentCount += tagItems.length;
      tagRelatedCount = tagItems.length;
      console.log(`‚úÖ ${type}: Agregados ${tagItems.length} items por tags (${uniqueTagItems.length} √∫nicos disponibles, ${remainingSlots} slots restantes)`);
    } else if (currentCount >= maxLimit) {
      console.log(`‚ö†Ô∏è  ${type}: No hay espacio para contenido por tags (espec√≠ficos llenaron ${currentCount}/${maxLimit})`);
    } else {
      console.log(`‚ö†Ô∏è  ${type}: No hay contenido por tags disponible`);
    }
    // üéØ PRIORIDAD 3: CONTENIDO POR DEFECTO (hasta l√≠mite total, sin duplicados)
    if (currentCount < maxLimit && defaultContent?.[type]) {
      const remainingSlots = maxLimit - currentCount;
      console.log(`üîß Procesando contenido por defecto para ${type}: ${defaultContent[type].length} disponibles, ${remainingSlots} slots restantes`);
      const uniqueDefaultItems = defaultContent[type].filter((item)=>{
        const isUnique = !usedIds.has(item.id);
        if (!isUnique) {
          console.log(`  ‚ö†Ô∏è Defecto duplicado evitado: ${item.id}`);
        }
        return isUnique;
      });
      const defaultItems = uniqueDefaultItems.slice(0, remainingSlots).map((item, index)=>{
        const cleanItem = {
          ...item,
          content_priority: 'default',
          is_default_content: true
        };
        // ‚úÖ LIMPIAR campos inconsistentes si existen
        delete cleanItem.total_weight;
        delete cleanItem.matched_tags;
        delete cleanItem.content_type;
        delete cleanItem.is_tag_related;
        delete cleanItem.is_property_specific;
        usedIds.add(item.id);
        console.log(`  ‚úÖ Defecto #${index + 1}: ${item.id} - ${item.title || item.question || 'Sin t√≠tulo'}`);
        return cleanItem;
      });
      finalItems.push(...defaultItems);
      currentCount += defaultItems.length;
      defaultCount = defaultItems.length;
      console.log(`‚úÖ ${type}: Agregados ${defaultItems.length} items por defecto (${uniqueDefaultItems.length} √∫nicos disponibles, ${remainingSlots} slots restantes)`);
    } else if (currentCount >= maxLimit) {
      console.log(`‚ö†Ô∏è  ${type}: No hay espacio para contenido por defecto (${currentCount}/${maxLimit} usado)`);
    } else {
      console.log(`‚ö†Ô∏è  ${type}: No hay contenido por defecto disponible`);
    }
    // ‚úÖ VERIFICACI√ìN FINAL DE ORDEN Y DUPLICADOS
    const finalIds = finalItems.map((item)=>item.id);
    const uniqueFinalIds = [
      ...new Set(finalIds)
    ];
    if (finalIds.length !== uniqueFinalIds.length) {
      console.error(`‚ùå ERROR CR√çTICO: Duplicados detectados en ${type}:`, {
        total: finalIds.length,
        unique: uniqueFinalIds.length,
        duplicates: finalIds.length - uniqueFinalIds.length
      });
    }
    // ‚úÖ VERIFICACI√ìN DE ORDEN (espec√≠ficos DEBEN estar primero)
    const priorities = finalItems.map((item)=>item.content_priority);
    const specificItems = finalItems.filter((item)=>item.content_priority === 'specific');
    const tagItems = finalItems.filter((item)=>item.content_priority === 'tag_related');
    const defaultItems = finalItems.filter((item)=>item.content_priority === 'default');
    console.log(`üìä ${type} RESULTADO FINAL:`);
    console.log(`   ‚îú‚îÄ Total final: ${finalItems.length} items`);
    console.log(`   ‚îú‚îÄ Distribuci√≥n: ${specificItems.length} espec√≠ficos ‚Üí ${tagItems.length} tags ‚Üí ${defaultItems.length} defecto`);
    console.log(`   ‚îú‚îÄ Orden correcto: ${priorities.join(' ‚Üí ')}`);
    console.log(`   ‚îú‚îÄ √önicos confirmados: ${uniqueFinalIds.length} de ${finalIds.length}`);
    console.log(`   ‚îú‚îÄ L√≠mite: ${finalItems.length}/${maxLimit} ${finalItems.length > maxLimit ? '(EXCEDIDO POR ESPEC√çFICOS)' : ''}`);
    console.log(`   ‚îî‚îÄ Sin duplicados: ${finalIds.length === uniqueFinalIds.length ? '‚úÖ' : '‚ùå'}`);
    // ‚úÖ ASIGNAR AL RESULTADO FINAL
    combined[type] = finalItems;
    // Actualizar contadores globales
    combined.hierarchy_info.specific_count += specificCount;
    combined.hierarchy_info.tag_related_count += tagRelatedCount;
    combined.hierarchy_info.default_count += defaultCount;
  }
  // Procesar todos los tipos de contenido
  [
    'articles',
    'videos',
    'testimonials',
    'faqs',
    'seo_content'
  ].forEach(combineContentType);
  // Determinar la fuente del contenido final
  const { specific_count, tag_related_count, default_count } = combined.hierarchy_info;
  if (specific_count > 0 && tag_related_count > 0) {
    combined.content_source = 'specific_and_tag_related_and_general';
  } else if (specific_count > 0) {
    combined.content_source = 'specific_and_general';
  } else if (tag_related_count > 0) {
    combined.content_source = 'tag_related_and_general';
  } else {
    combined.content_source = 'general_only';
  }
  console.log('\n‚úÖ === CONTENIDO COMBINADO EXITOSAMENTE (VERSI√ìN CORREGIDA) ===');
  console.log('üìä Resumen final:', {
    content_source: combined.content_source,
    total_items: specific_count + tag_related_count + default_count,
    hierarchy: combined.hierarchy_info,
    priority_guarantee: 'TODOS los espec√≠ficos incluidos PRIMERO',
    breakdown: {
      articles: `${combined.articles.length} total (${combined.articles.filter((a)=>a.content_priority === 'specific').length} espec√≠ficos)`,
      videos: `${combined.videos.length} total (${combined.videos.filter((v)=>v.content_priority === 'specific').length} espec√≠ficos)`,
      testimonials: `${combined.testimonials.length} total (${combined.testimonials.filter((t)=>t.content_priority === 'specific').length} espec√≠ficos)`,
      faqs: `${combined.faqs.length} total (${combined.faqs.filter((f)=>f.content_priority === 'specific').length} espec√≠ficos)`,
      seo_content: `${combined.seo_content.length} total (${combined.seo_content.filter((s)=>s.content_priority === 'specific').length} espec√≠ficos)`
    }
  });
  return combined;
}
// =====================================================
// FUNCIONES AUXILIARES (EXISTENTES)
// =====================================================
function parseUrlToSlugs(pathname) {
  const systemRoutes = [
    '/property-search',
    '/api',
    '/functions',
    '/_app',
    '/admin'
  ];
  if (systemRoutes.some((route)=>pathname.startsWith(route))) {
    return [];
  }
  return pathname.replace(/^\//, '').split('/').filter((segment)=>segment.length > 0).map((segment)=>segment.toLowerCase().trim());
}
// =====================================================
// ‚ú® FUNCI√ìN DE BREADCRUMBS UNIFICADA (COHERENTE)
// =====================================================
async function generateSmartBreadcrumbs(supabaseClient, tags, urlSegments, context = 'listing') {
  console.log('üçû === GENERANDO BREADCRUMBS INTELIGENTES ===');
  console.log('üìã Context:', context);
  console.log('üè∑Ô∏è Tags recibidos:', tags?.length || 0);
  console.log('üìé URL segments:', urlSegments);
  const breadcrumbs = [];
  // 1. INICIO siempre es el primer elemento
  breadcrumbs.push({
    name: 'Inicio',
    slug: '',
    url: '/',
    category: 'root',
    is_active: false,
    position: 0
  });
  if (!tags || tags.length === 0) {
    console.log('‚ö†Ô∏è No hay tags, retornando solo breadcrumb de inicio');
    return breadcrumbs;
  }
  // 2. Organizar tags por categor√≠a con prioridad espec√≠fica
  const tagsByCategory = {
    operacion: tags.filter((t)=>t.category === 'operacion'),
    categoria: tags.filter((t)=>t.category === 'categoria'),
    ciudad: tags.filter((t)=>t.category === 'ciudad'),
    sector: tags.filter((t)=>t.category === 'sector'),
    provincia: tags.filter((t)=>t.category === 'provincia'),
    otros: tags.filter((t)=>![
        'operacion',
        'categoria',
        'ciudad',
        'sector',
        'provincia'
      ].includes(t.category))
  };
  console.log('üìä Tags organizados por categor√≠a:', {
    operacion: tagsByCategory.operacion.length,
    categoria: tagsByCategory.categoria.length,
    ciudad: tagsByCategory.ciudad.length,
    sector: tagsByCategory.sector.length,
    provincia: tagsByCategory.provincia.length,
    otros: tagsByCategory.otros.length
  });
  // 3. Construcci√≥n progresiva de breadcrumbs siguiendo el patr√≥n jer√°rquico
  const hierarchyOrder = [
    'operacion',
    'categoria',
    'ciudad',
    'sector'
  ];
  let currentPath = '';
  let position = 1;
  // ‚úÖ COHERENCIA: Misma l√≥gica para ambos contextos (listing y single)
  for (const categoryKey of hierarchyOrder){
    const categoryTags = tagsByCategory[categoryKey];
    if (categoryTags.length > 0) {
      const tag = categoryTags[0];
      currentPath = currentPath ? `${currentPath}/${tag.slug}` : tag.slug;
      breadcrumbs.push({
        name: tag.display_name || tag.name,
        slug: tag.slug,
        url: `/${currentPath}`,
        category: tag.category,
        is_active: false,
        position: position,
        tag_id: tag.id,
        description: tag.description,
        icon: tag.icon
      });
      position++;
      console.log(`‚úÖ Agregado breadcrumb ${categoryKey}: ${tag.name} ‚Üí /${currentPath}`);
    }
  }
  // 4. Para contexto 'single', no agregar tags adicionales (se agrega la propiedad despu√©s)
  // Para contexto 'listing', agregar hasta 2 tags adicionales si est√°n en la URL
  if (context === 'listing' && tagsByCategory.otros.length > 0) {
    console.log('üìé Agregando tags adicionales para listado...');
    const additionalTags = tagsByCategory.otros.filter((tag)=>urlSegments.includes(tag.slug)).slice(0, 2);
    for (const tag of additionalTags){
      currentPath = `${currentPath}/${tag.slug}`;
      breadcrumbs.push({
        name: tag.display_name || tag.name,
        slug: tag.slug,
        url: `/${currentPath}`,
        category: tag.category,
        is_active: false,
        position: position,
        tag_id: tag.id,
        description: tag.description,
        icon: tag.icon
      });
      position++;
      console.log(`‚úÖ Agregado tag adicional: ${tag.name} ‚Üí /${currentPath}`);
    }
  }
  // 5. Marcar el √∫ltimo elemento como activo SOLO para listados
  if (context === 'listing' && breadcrumbs.length > 1) {
    breadcrumbs[breadcrumbs.length - 1].is_active = true;
  }
  // 6. Validar y limpiar breadcrumbs
  const validBreadcrumbs = breadcrumbs.filter((bc)=>bc.name && bc.name.trim().length > 0);
  console.log('‚úÖ === BREADCRUMBS GENERADOS EXITOSAMENTE ===');
  console.log('üìä Resumen:', {
    total_breadcrumbs: validBreadcrumbs.length,
    context: context,
    final_url: validBreadcrumbs[validBreadcrumbs.length - 1]?.url,
    structure: validBreadcrumbs.map((bc)=>`${bc.category}:${bc.name}`).join(' ‚Üí ')
  });
  return validBreadcrumbs;
}
async function generatePropertyBreadcrumbs(supabaseClient, property) {
  console.log('üè† Generando breadcrumbs para propiedad individual:', property.name);
  try {
    const propertyTags = await getPropertyTags(supabaseClient, property.id);
    if (propertyTags.length === 0) {
      return await generateFallbackPropertyBreadcrumbs(property);
    }
    // ‚úÖ COHERENCIA: Usar la misma funci√≥n con context 'single'
    const breadcrumbs = await generateSmartBreadcrumbs(supabaseClient, propertyTags, [], 'single');
    // Agregar la propiedad como elemento final
    const lastBreadcrumb = breadcrumbs[breadcrumbs.length - 1];
    const finalUrl = lastBreadcrumb ? `${lastBreadcrumb.url}/${property.slug_url || property.id}` : `/${property.slug_url || property.id}`;
    breadcrumbs.push({
      name: property.name,
      slug: property.slug_url || property.id,
      url: finalUrl,
      category: 'property',
      is_active: true,
      position: breadcrumbs.length,
      is_current_page: true
    });
    console.log('‚úÖ Breadcrumbs de propiedad generados:', breadcrumbs.length);
    return breadcrumbs;
  } catch (error) {
    console.error('‚ùå Error generando breadcrumbs de propiedad:', error);
    return await generateFallbackPropertyBreadcrumbs(property);
  }
}
async function generateFallbackPropertyBreadcrumbs(property) {
  const breadcrumbs = [
    {
      name: 'Inicio',
      slug: '',
      url: '/',
      category: 'root',
      is_active: false,
      position: 0
    }
  ];
  if (property.property_categories?.name) {
    const categorySlug = property.property_categories.name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9\-]/g, '');
    breadcrumbs.push({
      name: property.property_categories.name,
      slug: categorySlug,
      url: `/${categorySlug}`,
      category: 'categoria',
      is_active: false,
      position: 1
    });
  }
  if (property.cities?.name) {
    const citySlug = property.cities.name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9\-]/g, '');
    const previousUrl = breadcrumbs[breadcrumbs.length - 1].url;
    const cityUrl = previousUrl === '/' ? `/${citySlug}` : `${previousUrl}/${citySlug}`;
    breadcrumbs.push({
      name: property.cities.name,
      slug: citySlug,
      url: cityUrl,
      category: 'ciudad',
      is_active: false,
      position: breadcrumbs.length
    });
  }
  const lastBreadcrumb = breadcrumbs[breadcrumbs.length - 1];
  const finalUrl = `${lastBreadcrumb.url}/${property.slug_url || property.id}`;
  breadcrumbs.push({
    name: property.name,
    slug: property.slug_url || property.id,
    url: finalUrl,
    category: 'property',
    is_active: true,
    position: breadcrumbs.length,
    is_current_page: true
  });
  console.log('‚úÖ Breadcrumbs fallback generados para propiedad');
  return breadcrumbs;
}
async function findTagsBySlug(supabaseClient, slugs) {
  if (slugs.length === 0) return [];
  const { data: tags, error } = await supabaseClient.from('tags').select('id, name, slug, category, display_name').in('slug', slugs);
  if (error) {
    console.error('Error buscando tags:', error);
    return [];
  }
  return tags || [];
}
function extractLocationFromTags(tags) {
  const locationTag = tags?.find((tag)=>tag.category === 'ciudad' || tag.category === 'sector' || tag.category === 'provincia');
  return locationTag?.name || null;
}
function extractPropertyTypeFromTags(tags) {
  const typeTag = tags?.find((tag)=>tag.category === 'categoria');
  return typeTag?.name || null;
}
function extractOperationFromTags(tags) {
  const operationTag = tags?.find((tag)=>tag.category === 'operacion');
  return operationTag?.name || null;
}
// =====================================================
// FUNCI√ìN PRINCIPAL MEJORADA CON COORDENADAS Y ART√çCULOS CORREGIDOS
// =====================================================
Deno.serve(async (req)=>{
  if (req.method === 'OPTIONS') {
    return new Response('ok', {
      headers: corsHeaders
    });
  }
  try {
    const supabase = createClient('https://pacewqgypevfgjmdsorz.supabase.co', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBhY2V3cWd5cGV2ZmdqbWRzb3J6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg2NjU4OTksImV4cCI6MjA2NDI0MTg5OX0.Qlg-UVy-sikr76GxYmTcfCz1EnAqPHxvFeLrdqnjuWs');
    const url = new URL(req.url);
    const pathname = url.pathname;
    const pathSegments = pathname.split('/').filter((segment)=>segment.length > 0);
    const busquedaIndex = pathSegments.findIndex((segment)=>segment === 'busqueda');
    let slug = '';
    if (busquedaIndex !== -1 && busquedaIndex < pathSegments.length - 1) {
      slug = pathSegments.slice(busquedaIndex + 1).join('/');
    } else {
      slug = url.searchParams.get('url') || url.searchParams.get('slug') || '';
    }
    const refParam = url.searchParams.get('ref');
    const page = parseInt(url.searchParams.get('page')) || 1;
    const limit = parseInt(url.searchParams.get('limit')) || 32;
    if (!slug) {
      return new Response(JSON.stringify({
        error: 'Invalid URL format. Expected: /function-name/busqueda/your-slug-here',
        type: 'error',
        received_path: pathname
      }), {
        status: 400,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    console.log('üîç Iniciando b√∫squeda unificada:', {
      slug,
      refParam,
      page,
      limit
    });
    // Obtener usuario referido si existe
    let referralAgent = null;
    if (refParam) {
      referralAgent = await getReferralAgent(supabase, refParam);
    }
    // PASO 1: Intentar b√∫squeda por slug_url (propiedad individual)
    const propertyResult = await searchPropertyBySlugUrl(supabase, slug);
    // ‚úÖ CASO 1: PROPIEDAD DISPONIBLE CON COORDENADAS
    if (propertyResult.found && propertyResult.property && propertyResult.available) {
      console.log('‚úÖ Encontrada como propiedad DISPONIBLE');
      const property = propertyResult.property;
      const optimizedProperty = optimizePropertyImages(unifyPropertyPricing(property));
      // ‚úÖ PROCESAR COORDENADAS
      const coordinatesInfo = processPropertyCoordinates(property);
      const locationData = generateLocationData(property, coordinatesInfo);
      console.log('üìç === DATOS DE UBICACI√ìN GENERADOS ===');
      console.log('üó∫Ô∏è Location data:', locationData);
      // ‚úÖ MEJORA: Obtener propiedades del asesor
      console.log('üë§ Obteniendo propiedades del asesor...');
      const agentProperties = property.agent_id ? await getAgentProperties(supabase, property.agent_id, property.id, 20) : [];
      // Obtener propiedades similares con el nuevo sistema
      console.log('üè† Obteniendo propiedades similares...');
      const propertyTags = await getPropertyTags(supabase, property.id);
      const similarProperties = await getSmartSimilarProperties(supabase, propertyTags, property.id);
      // Obtener contenido relacionado por tags
      console.log('üè∑Ô∏è Obteniendo contenido relacionado por tags...');
      const tagIds = propertyTags.map((tag)=>tag.id);
      const tagRelatedContent = await getRelatedContent(supabase, tagIds, 10);
      // ‚úÖ AGREGAR OBTENCI√ìN DE STATS DE ART√çCULOS
      const [specificContent, defaultContent, projectDetails, agentData, googlePlacesData, articlesStats] = await Promise.all([
        getPropertySpecificContent(supabase, property.id),
        getDefaultRelatedContent(supabase),
        property.is_project && property.project_detail_id ? getCompleteProjectDetails(supabase, property.project_detail_id) : Promise.resolve(null),
        property.agent_id ? getPropertyAgent(supabase, property.agent_id) : Promise.resolve(null),
        property.sectors?.name || property.cities?.name ? getLocationGooglePlacesData(supabase, property.sectors?.name || property.cities?.name) : Promise.resolve(null),
        getArticlesStats(supabase) // ‚úÖ NUEVO
      ]);
      // Combinar contenido con jerarqu√≠a de tags
      const enhancedContent = combineContentWithTagsHierarchy(specificContent, tagRelatedContent, defaultContent);
      const responseType = property.is_project ? 'single-property-project' : 'single-property';
      const seoData = generateSEOMetadata({
        type: responseType,
        property: optimizedProperty,
        urlSegments: [
          slug
        ],
        googlePlacesData
      });
      const response = {
        type: responseType,
        available: property.property_status === 'Publicada',
        property: optimizedProperty,
        // ‚úÖ AGREGAR DATOS DE UBICACI√ìN MEJORADOS
        location: locationData,
        relatedContent: {
          ...enhancedContent,
          articles_stats: articlesStats // ‚úÖ NUEVO CAMPO
        },
        projectDetails: projectDetails || null,
        agent: formatAgent(agentData, 'agent') || null,
        referralAgent: formatAgent(referralAgent, 'referral') || null,
        // ‚úÖ MEJORA: Propiedades del asesor
        agentProperties: agentProperties,
        agentPropertiesInfo: {
          total_found: agentProperties.length,
          agent_id: property.agent_id,
          excluded_property: property.id,
          has_agent_properties: agentProperties.length > 0
        },
        similarProperties: similarProperties,
        similarPropertiesDebug: {
          total_found: similarProperties.length,
          tags_used: propertyTags.length,
          search_method: propertyTags.length > 0 ? 'smart_tags' : 'fallback'
        },
        breadcrumbs: await generatePropertyBreadcrumbs(supabase, property),
        seo: seoData,
        meta: {
          slug,
          searchPath: pathname,
          referralParam: refParam,
          contentHierarchy: enhancedContent.hierarchy_info,
          contentSource: enhancedContent.content_source,
          tagRelatedContentUsed: tagRelatedContent ? Object.keys(tagRelatedContent).some((key)=>tagRelatedContent[key] && tagRelatedContent[key].length > 0) : false,
          // ‚úÖ AGREGAR METADATOS DE COORDENADAS
          coordinatesProcessed: true,
          coordinatesSource: coordinatesInfo.source,
          showExactLocation: coordinatesInfo.showExactLocation,
          hasExactCoordinates: coordinatesInfo.hasExactCoordinates,
          locationDataGenerated: true,
          timestamp: new Date().toISOString()
        }
      };
      return new Response(JSON.stringify(response), {
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json',
          'Cache-Control': 'public, max-age=3600'
        }
      });
    }
    // ‚úÖ CASO 2: PROPIEDAD NO DISPONIBLE (VENDIDA/RETIRADA) CON COORDENADAS
    if (propertyResult.found && propertyResult.property && !propertyResult.available) {
      console.log('‚ö†Ô∏è Encontrada como propiedad NO DISPONIBLE - Status:', propertyResult.soldStatus);
      const property = propertyResult.property;
      const optimizedProperty = optimizePropertyImages(unifyPropertyPricing(property));
      // ‚úÖ PROCESAR COORDENADAS TAMBI√âN PARA PROPIEDADES NO DISPONIBLES
      const coordinatesInfo = processPropertyCoordinates(property);
      const locationData = generateLocationData(property, coordinatesInfo);
      console.log('üìç === DATOS DE UBICACI√ìN GENERADOS (NO DISPONIBLE) ===');
      console.log('üó∫Ô∏è Location data:', locationData);
      // ‚úÖ NUEVA FUNCIONALIDAD: Obtener propiedades similares como alternativas
      console.log('üîÑ Obteniendo propiedades similares como alternativas...');
      const propertyTags = await getPropertyTags(supabase, property.id);
      const similarProperties = await getSmartSimilarProperties(supabase, propertyTags, property.id);
      // ‚úÖ NUEVA FUNCIONALIDAD: Propiedades del asesor que ten√≠a la propiedad vendida
      console.log('üë§ Obteniendo otras propiedades del asesor...');
      const agentProperties = property.agent_id ? await getAgentProperties(supabase, property.agent_id, property.id, 20) : [];
      // ‚úÖ NUEVA FUNCIONALIDAD: Contenido relacionado enriquecido
      console.log('üè∑Ô∏è Obteniendo contenido relacionado para propiedad vendida...');
      const tagIds = propertyTags.map((tag)=>tag.id);
      const tagRelatedContent = await getRelatedContent(supabase, tagIds, 10); // M√°s contenido para compensar
      // ‚úÖ AGREGAR STATS DE ART√çCULOS TAMBI√âN PARA NO DISPONIBLES
      const [specificContent, defaultContent, projectDetails, agentData, googlePlacesData, articlesStats] = await Promise.all([
        getPropertySpecificContent(supabase, property.id),
        getDefaultRelatedContent(supabase),
        property.is_project && property.project_detail_id ? getCompleteProjectDetails(supabase, property.project_detail_id) : Promise.resolve(null),
        property.agent_id ? getPropertyAgent(supabase, property.agent_id) : Promise.resolve(null),
        property.sectors?.name || property.cities?.name ? getLocationGooglePlacesData(supabase, property.sectors?.name || property.cities?.name) : Promise.resolve(null),
        getArticlesStats(supabase) // ‚úÖ NUEVO TAMBI√âN AQU√ç
      ]);
      // Combinar contenido para propiedad no disponible
      const enhancedContent = combineContentWithTagsHierarchy(specificContent, tagRelatedContent, defaultContent);
      const responseType = 'property-not-available';
      const seoData = generateSEOMetadata({
        type: responseType,
        property: optimizedProperty,
        urlSegments: [
          slug
        ],
        googlePlacesData
      });
      const response = {
        type: responseType,
        available: false,
        soldStatus: propertyResult.soldStatus,
        property: optimizedProperty,
        // ‚úÖ AGREGAR DATOS DE UBICACI√ìN PARA PROPIEDADES NO DISPONIBLES
        location: locationData,
        // ‚úÖ ALTERNATIVAS Y CONTENIDO ENRIQUECIDO
        similarProperties: similarProperties,
        similarPropertiesDebug: {
          total_found: similarProperties.length,
          tags_used: propertyTags.length,
          search_method: 'smart_tags_for_sold_property',
          purpose: 'alternatives_for_sold_property'
        },
        agentProperties: agentProperties,
        agentPropertiesInfo: {
          total_found: agentProperties.length,
          agent_id: property.agent_id,
          excluded_property: property.id,
          has_agent_properties: agentProperties.length > 0,
          purpose: 'other_agent_listings'
        },
        relatedContent: {
          ...enhancedContent,
          articles_stats: articlesStats // ‚úÖ NUEVO CAMPO TAMBI√âN AQU√ç
        },
        projectDetails: projectDetails || null,
        agent: formatAgent(agentData, 'agent') || null,
        referralAgent: formatAgent(referralAgent, 'referral') || null,
        breadcrumbs: await generatePropertyBreadcrumbs(supabase, property),
        seo: seoData,
        message: `Esta propiedad ya no est√° disponible (${propertyResult.soldStatus}), pero encontramos propiedades similares y otras opciones del mismo asesor.`,
        meta: {
          slug,
          searchPath: pathname,
          referralParam: refParam,
          contentHierarchy: enhancedContent.hierarchy_info,
          contentSource: enhancedContent.content_source,
          tagRelatedContentUsed: true,
          propertyStatus: propertyResult.soldStatus,
          alternativesProvided: true,
          // ‚úÖ AGREGAR METADATOS DE COORDENADAS PARA NO DISPONIBLES
          coordinatesProcessed: true,
          coordinatesSource: coordinatesInfo.source,
          showExactLocation: coordinatesInfo.showExactLocation,
          hasExactCoordinates: coordinatesInfo.hasExactCoordinates,
          locationDataGenerated: true,
          timestamp: new Date().toISOString()
        }
      };
      return new Response(JSON.stringify(response), {
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json',
          'Cache-Control': 'public, max-age=1800'
        }
      });
    }
    // PASO 2: B√∫squeda por tags (listado de propiedades) CON COORDENADAS
    console.log('üîç Procesando como listado por tags');
    const urlSegments = parseUrlToSlugs(slug);
    const tags = await findTagsBySlug(supabase, urlSegments);
    const tagIds = tags.map((t)=>t.id);
    console.log('üè∑Ô∏è Tags encontrados:', {
      slugs: urlSegments,
      tagCount: tags.length
    });
    // B√∫squeda con paginaci√≥n (ya incluye coordenadas en la consulta)
    const searchResults = await searchPropertiesByTags(supabase, tagIds, page, limit);
    // Procesar propiedades en paralelo CON COORDENADAS
    console.log('üîÑ Procesando propiedades con coordenadas...');
    const enrichedProperties = await Promise.all((searchResults.properties || []).map(async (property)=>{
      const optimizedProperty = optimizePropertyImages(unifyPropertyPricing(property));
      // ‚úÖ PROCESAR COORDENADAS PARA CADA PROPIEDAD EN LISTADOS
      const coordinatesInfo = processPropertyCoordinates(property);
      const locationData = generateLocationData(property, coordinatesInfo);
      const [projectDetails, agentData] = await Promise.all([
        property.is_project && property.project_detail_id ? getCompleteProjectDetails(supabase, property.project_detail_id) : Promise.resolve(null),
        property.agent_id ? getPropertyAgent(supabase, property.agent_id) : Promise.resolve(null)
      ]);
      return {
        ...optimizedProperty,
        // ‚úÖ AGREGAR COORDENADAS A CADA PROPIEDAD EN LISTADOS
        location: locationData,
        projectDetails: projectDetails || null,
        agent: formatAgent(agentData, 'agent') || null
      };
    }));
    // ‚úÖ MEJORA: Contenido relacionado por tags para listados
    console.log('üè∑Ô∏è Obteniendo contenido relacionado por tags para listado...');
    const tagRelatedContent = tagIds.length > 0 ? await getRelatedContent(supabase, tagIds, 10) : {
      articles: [],
      videos: [],
      testimonials: [],
      faqs: [],
      seo_content: []
    };
    // Obtener contenido por defecto como fallback
    const defaultContent = await getDefaultRelatedContent(supabase);
    // ‚úÖ AGREGAR STATS DE ART√çCULOS PARA LISTADOS
    const [googlePlacesData, articlesStats] = await Promise.all([
      extractLocationFromTags(tags) ? getLocationGooglePlacesData(supabase, extractLocationFromTags(tags)) : null,
      getArticlesStats(supabase) // ‚úÖ NUEVO PARA LISTADOS
    ]);
    // ‚úÖ MEJORA: Combinar contenido por tags + por defecto para listados
    const enhancedListingContent = combineContentWithTagsHierarchy(null, tagRelatedContent, defaultContent);
    // ‚úÖ AGREGAR STATS AL ENHANCED CONTENT
    enhancedListingContent.articles_stats = articlesStats;
    const seoData = generateSEOMetadata({
      type: 'property-list',
      searchResults: {
        properties: enrichedProperties,
        pagination: {
          currentPage: searchResults.currentPage,
          totalCount: searchResults.totalCount,
          itemsPerPage: searchResults.itemsPerPage,
          totalPages: Math.ceil(searchResults.totalCount / searchResults.itemsPerPage),
          hasMore: searchResults.hasMore
        }
      },
      tags,
      urlSegments,
      googlePlacesData
    });
    const response = {
      type: 'property-list',
      available: true,
      searchResults: {
        properties: enrichedProperties,
        tags,
        searchTerms: urlSegments,
        pagination: {
          currentPage: searchResults.currentPage,
          totalCount: searchResults.totalCount,
          itemsPerPage: searchResults.itemsPerPage,
          totalPages: Math.ceil(searchResults.totalCount / searchResults.itemsPerPage),
          hasMore: searchResults.hasMore,
          hasNextPage: searchResults.hasMore,
          hasPreviousPage: searchResults.currentPage > 1
        }
      },
      // ‚úÖ MEJORA: Contenido relacionado por tags en lugar de solo por defecto
      relatedContent: {
        ...enhancedListingContent,
        articles_stats: articlesStats // ‚úÖ NUEVO CAMPO PARA LISTADOS
      },
      referralAgent: formatAgent(referralAgent, 'referral') || null,
      breadcrumbs: await generateSmartBreadcrumbs(supabase, tags, urlSegments, 'listing'),
      seo: seoData,
      meta: {
        slug,
        searchPath: pathname,
        urlSegments,
        referralParam: refParam,
        page,
        limit,
        // ‚úÖ NUEVOS METADATOS: Informaci√≥n de contenido por tags en listados
        contentHierarchy: enhancedListingContent.hierarchy_info,
        contentSource: enhancedListingContent.content_source,
        tagRelatedContentUsed: tagRelatedContent ? Object.keys(tagRelatedContent).some((key)=>tagRelatedContent[key] && tagRelatedContent[key].length > 0) : false,
        tagCount: tagIds.length,
        // ‚úÖ AGREGAR METADATOS DE COORDENADAS PARA LISTADOS
        propertiesWithCoordinates: enrichedProperties.filter((p)=>p.location?.coordinates).length,
        coordinatesProcessedForAll: true,
        timestamp: new Date().toISOString()
      }
    };
    return new Response(JSON.stringify(response), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
        'Cache-Control': 'public, max-age=1800'
      }
    });
  } catch (error) {
    console.error('Edge function error:', error);
    return new Response(JSON.stringify({
      error: 'Internal server error',
      type: 'error',
      details: error.message
    }), {
      status: 500,
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  }
});